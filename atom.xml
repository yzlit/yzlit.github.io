<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>酒夜狸个人博客</title>
  
  <subtitle>酒夜狸的个人博客，欢迎探讨有关java,python,go,linux后台技术，诗歌，科幻，人生。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yzlit.github.io/"/>
  <updated>2019-01-13T07:30:21.203Z</updated>
  <id>https://yzlit.github.io/</id>
  
  <author>
    <name>酒夜狸</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>跨域问题详解</title>
    <link href="https://yzlit.github.io/2019/01/13/Cross-domain-Access/"/>
    <id>https://yzlit.github.io/2019/01/13/Cross-domain-Access/</id>
    <published>2019-01-13T04:23:55.000Z</published>
    <updated>2019-01-13T07:30:21.203Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、什么是跨域？"><a href="#一、什么是跨域？" class="headerlink" title="一、什么是跨域？"></a>一、什么是跨域？</h3><p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1547370259736&amp;di=4a7c40b675fb2647cda6e5b6edacbef5&amp;imgtype=0&amp;src=http%3A%2F%2Fp.blog.csdn.net%2Fimages%2Fp_blog_csdn_net%2FPointer_v%2FEntryImages%2F20090212%2Fproxy2.gif" alt="img"></p><p>浏览器从一个域名的网页去请求另一个域名的资源时，域名、端口、协议任一不同，都是跨域。跨域访问会访问状态码200但是无法访问，还有其他附带的问题，请求COOKIE无法带上。</p><p>比如你从域名为120.258.45 的index.html要访问 156.85.14:8000/getaccess 接口，那么就会有跨域问题。一般尝试跨域访问就会出现No ‘Access-Control-Allow-Origin’ header is present on the requested resource.’ ，类似你可以从谷歌控制台，看到提示：</p><img src="/2019/01/13/Cross-domain-Access/20190113132225.png" title="这是一个测试"><h3 id="二、为什么要禁止跨域访问"><a href="#二、为什么要禁止跨域访问" class="headerlink" title="二、为什么要禁止跨域访问"></a>二、为什么要禁止跨域访问</h3><p>这要涉及到浏览器的同源策略，同源策略限制了不同源之间的资源进行交互，用于隔离潜在的恶意文件的安全机制，并且是浏览器最基本的安全机制（同源：协议、域名、端口均相同，localhost和127.0.0.1也属于跨域）。</p><p>如果非同源，<strong>同源政策限制三种行为</strong>：</p><p>（1） Cookie、LocalStorage 和 IndexDB 无法读取。</p><p>（2） DOM 无法获得。</p><p>（3） AJAX 请求不能发送。</p><p>对于（1） Cookie、LocalStorage 和 IndexDB 无法读取，如果没有同源策略的限制，假设您进入一个受信网站A，输入了账号密码进行登录，服务器端验证通过后会在响应头中添加Set-Cookie字段，在下次访问时，浏览器就会将cookie附加在http请求头字段Cookie中，服务器就知道您已经登录过，下次你再带着这个cookie时访问受信网站A，服务器便不再验证了，如果在cookie信息还存在的情况下，您不小心访问另一个恶意钓鱼网站B，在您不知情的情况下向受信网站A发起了请求，这就相当于不法钓鱼网站登录了您的账户，可以为所欲为了！</p><p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1547370029724&amp;di=bb03e9658d9d929fedb977dfea332fa3&amp;imgtype=0&amp;src=http%3A%2F%2Faliyunzixunbucket.oss-cn-beijing.aliyuncs.com%2Fpng%2Fdd2d206d5afa78c483611418500872bc.png" alt="img"></p><p>对于（2） DOM 无法获得。又比如一个钓鱼网站，模仿银行网站A（没有了同源策略的限制，钓鱼网站就可以很轻松的网站A的DOM），诱导您输入账户密码信息，你的信息就没了，所以最近12306就是因为类似第三方的访问导致410万用户密码等信息泄漏。</p><p>对于（3） AJAX 请求不能发送同源政策规定，AJAX请求只能发给同源的网址，否则就报错。</p><p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1547370063925&amp;di=84fd25a37be6345294e3688294f5d791&amp;imgtype=0&amp;src=http%3A%2F%2F5b0988e595225.cdn.sohucs.com%2Fq_70%2Cc_zoom%2Cw_640%2Fimages%2F20180722%2F377baa2adfb34e04b15a80ec41554cdb.jpeg" alt="img"></p><h3 id="三、怎么解决跨域问题"><a href="#三、怎么解决跨域问题" class="headerlink" title="三、怎么解决跨域问题"></a>三、怎么解决跨域问题</h3><p>详细的同源策略通过前端解决的介绍可以看阮一峰的文章<br><a href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html</a></p><p>除了上述解决方法，服务端解决跨域会用到CORS，CORS是一个W3C标准，全称是”跨域资源共享“。详细的可以见阮一峰的文章<br><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/04/cors.html</a></p><h2 id="Nginx配置实例"><a href="#Nginx配置实例" class="headerlink" title="Nginx配置实例"></a>Nginx配置实例</h2><h3 id="实例一：允许example-com的应用在www-example2-com上跨域提取数据"><a href="#实例一：允许example-com的应用在www-example2-com上跨域提取数据" class="headerlink" title="实例一：允许example.com的应用在www.example2.com上跨域提取数据"></a>实例一：允许example.com的应用在<a href="http://www.example2.com上跨域提取数据" target="_blank" rel="noopener">www.example2.com上跨域提取数据</a></h3><p>在nginx.conf里找到server项,并在里面添加如下配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`location /&#123;` `add_header ``&apos;Access-Control-Allow-Origin&apos;` `&apos;http://example.com&apos;``;``add_header ``&apos;Access-Control-Allow-Credentials&apos;` `&apos;true&apos;``;``add_header ``&apos;Access-Control-Allow-Headers&apos;` `&apos;Authorization,Content-Type,Accept,Origin,User-Agent,DNT,Cache-Control,X-Mx-ReqToken,X-Requested-With&apos;``;``add_header ``&apos;Access-Control-Allow-Methods&apos;` `&apos;GET,POST,OPTIONS&apos;``;``...``&#125;`</span><br></pre></td></tr></table></figure><p>如果需要允许来自任何域的访问，可以这样配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`add_header Access-Control-Allow-Origin *;`</span><br></pre></td></tr></table></figure><p>注释如下</p><p>第一条指令：授权从example.com的请求(必需)</p><p>第二条指令：当该标志为真时，响应于该请求是否可以被暴露(可选)</p><p>第三条指令：允许脚本访问的返回头(可选)</p><p>第四条指令：指定请求的方法，可以是GET, POST, OPTIONS, PUT, DELETE等(可选)</p><p>重启Nginx</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`$ service nginx reload`</span><br></pre></td></tr></table></figure><p>测试跨域请求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`$ curl -I -X OPTIONS -H ``&quot;Origin: http://example.com&quot;` `http:``//www``.example2.com`</span><br></pre></td></tr></table></figure><p>成功时，响应头是如下所示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`HTTP``/1``.1 200 OK``Server: nginx``Access-Control-Allow-Origin: example.com`</span><br></pre></td></tr></table></figure><h3 id="实例二：Nginx允许多个域名跨域访问"><a href="#实例二：Nginx允许多个域名跨域访问" class="headerlink" title="实例二：Nginx允许多个域名跨域访问"></a>实例二：Nginx允许多个域名跨域访问</h3><p>由于Access-Control-Allow-Origin参数只允许配置单个域名或者 * ，当我们需要允许多个域名跨域访问时可以用以下几种方法来实现。</p><ul><li>方法一</li></ul><p>如需要允许用户请求来自<a href="http://www.example.com、m.example.com、wap.example.com访问www.example2.com域名时，返回头Access-Control-Allow-Origin，具体配置如下" target="_blank" rel="noopener">www.example.com、m.example.com、wap.example.com访问www.example2.com域名时，返回头Access-Control-Allow-Origin，具体配置如下</a></p><p>在nginx.conf里面,找到server项,并在里面添加如下配置</p><p>具体其他可看：<a href="https://www.cnblogs.com/sunmmi/articles/5956554.html" target="_blank" rel="noopener">https://www.cnblogs.com/sunmmi/articles/5956554.html</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`map $http_origin $corsHost &#123;``    ``default 0;``    ``&quot;~http://www.example.com&quot;` `http:``//www``.example.com;``    ``&quot;~http://m.example.com&quot;` `http:``//m``.example.com;``    ``&quot;~http://wap.example.com&quot;` `http:``//wap``.example.com;``&#125;` `server``&#123;``    ``listen 80;``    ``server_name www.example2.com;``    ``root ``/usr/share/nginx/html``;``    ``location /``    ``&#123;``        ``add_header Access-Control-Allow-Origin $corsHost;``    ``&#125;``&#125;`</span><br></pre></td></tr></table></figure><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="450" src="http://music.163.com/outchain/player?type=0&id=815573174&auto=0&height=430"><br></iframe>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、什么是跨域？&quot;&gt;&lt;a href=&quot;#一、什么是跨域？&quot; class=&quot;headerlink&quot; title=&quot;一、什么是跨域？&quot;&gt;&lt;/a&gt;一、什么是跨域？&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://timgsa.baidu.com/timg?image&amp;
      
    
    </summary>
    
    
      <category term="跨域访问" scheme="https://yzlit.github.io/tags/%E8%B7%A8%E5%9F%9F%E8%AE%BF%E9%97%AE/"/>
    
  </entry>
  
  <entry>
    <title>从服务端来讲讲限流的思路</title>
    <link href="https://yzlit.github.io/2019/01/12/%E5%8D%81%E5%87%A0%E5%B9%B4%E5%90%8E%E5%8F%B0%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%9D%A5%E8%AE%B2%E8%AE%B2%E9%99%90%E6%B5%81%E7%9A%84%E6%80%9D%E8%B7%AF/"/>
    <id>https://yzlit.github.io/2019/01/12/十几年后台工程师来讲讲限流的思路/</id>
    <published>2019-01-12T15:46:47.000Z</published>
    <updated>2019-01-13T06:10:01.466Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-”两窗两桶“限流算法"><a href="#一-”两窗两桶“限流算法" class="headerlink" title="一 ”两窗两桶“限流算法"></a>一 ”两窗两桶“限流算法</h3><h4 id="1、固定窗口"><a href="#1、固定窗口" class="headerlink" title="1、固定窗口"></a>1、固定窗口</h4><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20181222/b991453cf5a74d4ba430f1be5ea6d776.jpg" alt="img"></p><p>固定窗口指的是为一定时间段的流量设置一个阈值，超过则触发限流策略（丢弃或者停留），然后直到下一个时间段重新置零开始计数，</p><p>这种策略很明显一个缺点是这个时间段的间隔要设置得好，否则会存在一个问题，就是无法“削峰填谷”，当时间间隔设为10秒100个请求量时，本来是应该正常每秒10个请求，但是突然第一秒就来了100个请求，在第一秒就变成100个请求每秒了，所以是没法达到限流缓冲的效果，所以这种策略比较粗暴简单。</p><p>「滑动窗口」可以改善上面的问题。</p><h4 id="2、滑动窗口"><a href="#2、滑动窗口" class="headerlink" title="2、滑动窗口"></a>2、滑动窗口</h4><p>滑动窗口算法 类似于我们学过TCP的滑动窗口，对固定窗口的一种优化。</p><p>滑动窗口就是对固定窗口做了进一步的细分，将原先的粒度切的更细，比如1分钟的固定窗口切分为60个1秒的滑动窗口。然后统计的时间范围随着时间的推移同步后移。</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20181222/e87df09d3ffd414f88a43c43d0423631.jpg" alt="img"></p><p>虽然说滑动窗口可以改善这个问题，但是本质上还是预先划定时间片的方式，属于一种“预测”，意味着几乎肯定无法做到100%的物尽其用。</p><p>问题在在于由于访问量的不可预见性，会发生单位时间的前半段大量请求涌入，而后半段则拒绝所有请求的情况。（通常，需要可以将单位时间切的足够的小来缓解 ）其次，我们很难确定这个阈值设置在多少比较合适，只能通过经验或者模拟（如压测）来进行估计，即使是压测也很难估计的准确。集群部署中每台机器的硬件参数不同，可能导致我们需要对每台机器的阈值设置的都不尽相同。同一台机子在不同的时间点的系统压力也不一样（比如晚上还有一些任务，或其他的一些业务操作的影响），能够承受的最大阈值也不尽相同，我们无法考虑的周全。 </p><p>所以滑窗模式通常适用于对某一资源的保护的需求上（或者说是承诺比较合适：我对某一接口的提供者承诺过，最高调用量不超过XX），如对db的保护，对某一服务的调用的控制上。  </p><h4 id="3，漏桶算法"><a href="#3，漏桶算法" class="headerlink" title="3，漏桶算法"></a>3，漏桶算法</h4><h4 id="4，令牌桶算法"><a href="#4，令牌桶算法" class="headerlink" title="4，令牌桶算法"></a>4，令牌桶算法</h4><h3 id="二、做「限流」的最佳实践"><a href="#二、做「限流」的最佳实践" class="headerlink" title="二、做「限流」的最佳实践"></a><strong>二、做「限流」的最佳实践</strong></h3><h4 id="1、四种策略该如何选择？"><a href="#1、四种策略该如何选择？" class="headerlink" title="1、四种策略该如何选择？"></a>1、四种策略该如何选择？</h4><p>首先，<strong>固定窗口</strong>。一般来说，如非时间紧迫，不建议选择这个方案，太过生硬。但是，为了能快速止损眼前的问题可以作为临时应急的方案。</p><p>其次，<strong>滑动窗口</strong>。这个方案适用于对异常结果「高容忍」的场景，毕竟相比“两窗”少了一个缓冲区。但是，胜在实现简单。</p><p>然后，<strong>漏桶</strong>。个人觉得这个方案最适合作为一个通用方案。虽说资源的利用率上不是极致，但是「宽进严出」的思路在保护系统的同时还留有一些余地，使得它的适用场景更广。</p><p>最后，<strong>令牌桶</strong>。当你需要尽可能的压榨程序的性能（此时桶的最大容量必然会大于等于程序的最大并发能力），并且所处的场景流量进入波动不是很大（不至于一瞬间取完令牌，压垮后端系统）。</p><h3 id="三、如何做分布式限流"><a href="#三、如何做分布式限流" class="headerlink" title="三、如何做分布式限流"></a>三、如何做分布式限流</h3><p>如果要分布式限流，那么单机限流的策略其实只需要移植一下，用新的工具如redis+lua 或者nginx+lua 又或者用zookeeper也是可以实现的，下面先具体讲讲redis+lua的分布式限流的思路和代码例子，其他有空再补上。</p><p>redis做限流的思路是先设置一个key=service1的记录，值为流量，和时间戳。这些用lua来主要是因为redis不支持事务，而lua脚本是作为一个原子操作一起执行的，lua脚本也是会存在reids内存中作为经常执行的命令串。</p><p>下面是固定窗口算法的lua脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">local key = KEYS[1]             </span><br><span class="line">local limit = tonumber(KEYS[2])   ## 限流</span><br><span class="line">local current = tonumber(redis.call(&apos;get&apos;, key) or 0)</span><br><span class="line"></span><br><span class="line">if current + 1 &gt; limit then</span><br><span class="line">    return 0</span><br><span class="line">else</span><br><span class="line">    redis.call(&quot;INCRBY&quot;, key,&quot;1&quot;)    ## 对key 加1操作</span><br><span class="line">    redis.call(&quot;EXPIRE&quot;, key,&quot;10&quot;)   ## 过期时间设为10秒</span><br><span class="line">    return 1</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>下面是令牌桶算法的lua脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">--- 获取令牌</span><br><span class="line">--- 返回码</span><br><span class="line">--- 0 没有令牌桶配置</span><br><span class="line">--- -1 表示取令牌失败，也就是桶里没有令牌</span><br><span class="line">--- 1 表示取令牌成功</span><br><span class="line">--- @param key 令牌（资源）的唯一标识</span><br><span class="line">--- @param permits 请求令牌数量</span><br><span class="line">--- @param curr_mill_second 当前毫秒数</span><br><span class="line">--- @param context 使用令牌的应用标识</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">local function acquire(key, permits, curr_mill_second, context)</span><br><span class="line">redis.pcall(&quot;HSET&quot;, key, &quot;max_permits&quot;, &quot;5&quot;)</span><br><span class="line">local rate_limit_info = redis.pcall(&quot;HMGET&quot;, key, &quot;last_mill_second&quot;, &quot;curr_permits&quot;, &quot;max_permits&quot;, &quot;rate&quot;, &quot;apps&quot;)</span><br><span class="line">local last_mill_second = rate_limit_info[1]</span><br><span class="line">local curr_permits = tonumber(rate_limit_info[2])</span><br><span class="line">local max_permits = tonumber(rate_limit_info[3])</span><br><span class="line">local rate = rate_limit_info[4]</span><br><span class="line">local apps = rate_limit_info[5]</span><br><span class="line">--- 标识没有配置令牌桶</span><br><span class="line">if type(apps) == &apos;boolean&apos; or apps == nil or string.find(apps, context, 1)~=nil  then</span><br><span class="line">redis.pcall(&quot;HSET&quot;, key, &quot;apps&quot;, context)</span><br><span class="line">apps=context</span><br><span class="line">end</span><br><span class="line">if type(rate) == &apos;boolean&apos; or rate == nil then</span><br><span class="line">redis.pcall(&quot;HSET&quot;, key, &quot;rate&quot;, &quot;0.2&quot;)</span><br><span class="line">rate=0.2</span><br><span class="line">end</span><br><span class="line">if type(curr_permits) == &apos;boolean&apos; or curr_permits == nil then</span><br><span class="line">redis.pcall(&quot;HSET&quot;, key, &quot;curr_permits&quot;, &quot;0&quot;)</span><br><span class="line">end</span><br><span class="line">local local_curr_permits = max_permits;</span><br><span class="line">--- 令牌桶刚刚创建，上一次获取令牌的毫秒数为空</span><br><span class="line">--- 根据和上一次向桶里添加令牌的时间和当前时间差，触发式往桶里添加令牌</span><br><span class="line">--- 并且更新上一次向桶里添加令牌的时间</span><br><span class="line">--- 如果向桶里添加的令牌数不足一个，则不更新上一次向桶里添加令牌的时间</span><br><span class="line">if (type(last_mill_second) ~= &apos;boolean&apos; and last_mill_second ~= false and last_mill_second ~= nil) then</span><br><span class="line">local reverse_permits = math.floor(((curr_mill_second - last_mill_second) / 1000) * rate)</span><br><span class="line">local expect_curr_permits = reverse_permits + curr_permits;</span><br><span class="line">local_curr_permits = math.min(expect_curr_permits, max_permits);</span><br><span class="line">--- 大于0表示不是第一次获取令牌，也没有向桶里添加令牌</span><br><span class="line">if (reverse_permits &gt; 0) then</span><br><span class="line">redis.pcall(&quot;HSET&quot;, key, &quot;last_mill_second&quot;, curr_mill_second)</span><br><span class="line">end</span><br><span class="line">else</span><br><span class="line">redis.pcall(&quot;HSET&quot;, key, &quot;last_mill_second&quot;, curr_mill_second)</span><br><span class="line">end</span><br><span class="line">local result = -1</span><br><span class="line">if (local_curr_permits - permits &gt;= 0) then</span><br><span class="line">result = 1</span><br><span class="line">redis.pcall(&quot;HSET&quot;, key, &quot;curr_permits&quot;, local_curr_permits - permits)</span><br><span class="line">else</span><br><span class="line">redis.pcall(&quot;HSET&quot;, key, &quot;curr_permits&quot;, local_curr_permits)</span><br><span class="line">end</span><br><span class="line">return result</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">return acquire(KEYS[1],tonumber(KEYS[2]),tonumber(KEYS[3]),KEYS[4])</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一-”两窗两桶“限流算法&quot;&gt;&lt;a href=&quot;#一-”两窗两桶“限流算法&quot; class=&quot;headerlink&quot; title=&quot;一 ”两窗两桶“限流算法&quot;&gt;&lt;/a&gt;一 ”两窗两桶“限流算法&lt;/h3&gt;&lt;h4 id=&quot;1、固定窗口&quot;&gt;&lt;a href=&quot;#1、固定窗口&quot;
      
    
    </summary>
    
    
      <category term="限流,固定窗口,滑动窗口,漏桶,令牌桶" scheme="https://yzlit.github.io/tags/%E9%99%90%E6%B5%81-%E5%9B%BA%E5%AE%9A%E7%AA%97%E5%8F%A3-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3-%E6%BC%8F%E6%A1%B6-%E4%BB%A4%E7%89%8C%E6%A1%B6/"/>
    
  </entry>
  
</feed>
