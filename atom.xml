<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>酒夜狸个人博客</title>
  
  <subtitle>酒夜狸的个人博客，欢迎探讨有关java,python,go,linux后台技术，诗歌，科幻，人生。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yzlit.github.io/"/>
  <updated>2019-01-12T16:46:39.224Z</updated>
  <id>https://yzlit.github.io/</id>
  
  <author>
    <name>酒夜狸</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>十几年后台工程师来讲讲限流的思路</title>
    <link href="https://yzlit.github.io/2019/01/12/%E5%8D%81%E5%87%A0%E5%B9%B4%E5%90%8E%E5%8F%B0%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%9D%A5%E8%AE%B2%E8%AE%B2%E9%99%90%E6%B5%81%E7%9A%84%E6%80%9D%E8%B7%AF/"/>
    <id>https://yzlit.github.io/2019/01/12/十几年后台工程师来讲讲限流的思路/</id>
    <published>2019-01-12T15:46:47.000Z</published>
    <updated>2019-01-12T16:46:39.224Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-”两窗两桶“限流算法"><a href="#一-”两窗两桶“限流算法" class="headerlink" title="一 ”两窗两桶“限流算法"></a>一 ”两窗两桶“限流算法</h3><h4 id="1、固定窗口"><a href="#1、固定窗口" class="headerlink" title="1、固定窗口"></a>1、固定窗口</h4><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20181222/b991453cf5a74d4ba430f1be5ea6d776.jpg" alt="img"></p><p>固定窗口指的是为一定时间段的流量设置一个阈值，超过则触发限流策略（丢弃或者停留），然后直到下一个时间段重新置零开始计数，</p><p>这种策略很明显一个缺点是这个时间段的间隔要设置得好，否则会存在一个问题，就是无法“削峰填谷”，当时间间隔设为10秒100个请求量时，本来是应该正常每秒10个请求，但是突然第一秒就来了100个请求，在第一秒就变成100个请求每秒了，所以是没法达到限流缓冲的效果，所以这种策略比较粗暴简单。</p><p>「滑动窗口」可以改善上面的问题。</p><h4 id="2、滑动窗口"><a href="#2、滑动窗口" class="headerlink" title="2、滑动窗口"></a>2、滑动窗口</h4><p>滑动窗口算法 类似于我们学过TCP的滑动窗口，对固定窗口的一种优化。</p><p>滑动窗口就是对固定窗口做了进一步的细分，将原先的粒度切的更细，比如1分钟的固定窗口切分为60个1秒的滑动窗口。然后统计的时间范围随着时间的推移同步后移。</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20181222/e87df09d3ffd414f88a43c43d0423631.jpg" alt="img"></p><p>虽然说滑动窗口可以改善这个问题，但是本质上还是预先划定时间片的方式，属于一种“预测”，意味着几乎肯定无法做到100%的物尽其用。</p><p>问题在在于由于访问量的不可预见性，会发生单位时间的前半段大量请求涌入，而后半段则拒绝所有请求的情况。（通常，需要可以将单位时间切的足够的小来缓解 ）其次，我们很难确定这个阈值设置在多少比较合适，只能通过经验或者模拟（如压测）来进行估计，即使是压测也很难估计的准确。集群部署中每台机器的硬件参数不同，可能导致我们需要对每台机器的阈值设置的都不尽相同。同一台机子在不同的时间点的系统压力也不一样（比如晚上还有一些任务，或其他的一些业务操作的影响），能够承受的最大阈值也不尽相同，我们无法考虑的周全。 </p><p>所以滑窗模式通常适用于对某一资源的保护的需求上（或者说是承诺比较合适：我对某一接口的提供者承诺过，最高调用量不超过XX），如对db的保护，对某一服务的调用的控制上。  </p><h4 id="3，漏桶算法"><a href="#3，漏桶算法" class="headerlink" title="3，漏桶算法"></a>3，漏桶算法</h4><h4 id="4，令牌桶算法"><a href="#4，令牌桶算法" class="headerlink" title="4，令牌桶算法"></a>4，令牌桶算法</h4><h3 id="二、做「限流」的最佳实践"><a href="#二、做「限流」的最佳实践" class="headerlink" title="二、做「限流」的最佳实践"></a><strong>二、做「限流」的最佳实践</strong></h3><h4 id="1、四种策略该如何选择？"><a href="#1、四种策略该如何选择？" class="headerlink" title="1、四种策略该如何选择？"></a>1、四种策略该如何选择？</h4><p>首先，<strong>固定窗口</strong>。一般来说，如非时间紧迫，不建议选择这个方案，太过生硬。但是，为了能快速止损眼前的问题可以作为临时应急的方案。</p><p>其次，<strong>滑动窗口</strong>。这个方案适用于对异常结果「高容忍」的场景，毕竟相比“两窗”少了一个缓冲区。但是，胜在实现简单。</p><p>然后，<strong>漏桶</strong>。个人觉得这个方案最适合作为一个通用方案。虽说资源的利用率上不是极致，但是「宽进严出」的思路在保护系统的同时还留有一些余地，使得它的适用场景更广。</p><p>最后，<strong>令牌桶</strong>。当你需要尽可能的压榨程序的性能（此时桶的最大容量必然会大于等于程序的最大并发能力），并且所处的场景流量进入波动不是很大（不至于一瞬间取完令牌，压垮后端系统）。</p><h3 id="三、如何做分布式限流"><a href="#三、如何做分布式限流" class="headerlink" title="三、如何做分布式限流"></a>三、如何做分布式限流</h3><p>如果要分布式限流，那么单机限流的策略其实只需要移植一下，用新的工具如redis+lua 或者nginx+lua 又或者用zookeeper也是可以实现的，下面先具体讲讲redis+lua的分布式限流的思路和代码例子，其他有空再补上。</p><p>redis做限流的思路是先设置一个key=service1的记录，值为流量，和时间戳。这些用lua来主要是因为redis不支持事务，而lua脚本是作为一个原子操作一起执行的，lua脚本也是会存在reids内存中作为经常执行的命令串。</p><p>下面是固定窗口算法的lua脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">local key = KEYS[1]             </span><br><span class="line">local limit = tonumber(KEYS[2])   ## 限流</span><br><span class="line">local current = tonumber(redis.call(&apos;get&apos;, key) or 0)</span><br><span class="line"></span><br><span class="line">if current + 1 &gt; limit then</span><br><span class="line">    return 0</span><br><span class="line">else</span><br><span class="line">    redis.call(&quot;INCRBY&quot;, key,&quot;1&quot;)    ## 对key 加1操作</span><br><span class="line">    redis.call(&quot;EXPIRE&quot;, key,&quot;10&quot;)   ## 过期时间设为10秒</span><br><span class="line">    return 1</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>下面是令牌桶算法的lua脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">--- 获取令牌</span><br><span class="line">--- 返回码</span><br><span class="line">--- 0 没有令牌桶配置</span><br><span class="line">--- -1 表示取令牌失败，也就是桶里没有令牌</span><br><span class="line">--- 1 表示取令牌成功</span><br><span class="line">--- @param key 令牌（资源）的唯一标识</span><br><span class="line">--- @param permits 请求令牌数量</span><br><span class="line">--- @param curr_mill_second 当前毫秒数</span><br><span class="line">--- @param context 使用令牌的应用标识</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">local function acquire(key, permits, curr_mill_second, context)</span><br><span class="line">redis.pcall(&quot;HSET&quot;, key, &quot;max_permits&quot;, &quot;5&quot;)</span><br><span class="line">local rate_limit_info = redis.pcall(&quot;HMGET&quot;, key, &quot;last_mill_second&quot;, &quot;curr_permits&quot;, &quot;max_permits&quot;, &quot;rate&quot;, &quot;apps&quot;)</span><br><span class="line">local last_mill_second = rate_limit_info[1]</span><br><span class="line">local curr_permits = tonumber(rate_limit_info[2])</span><br><span class="line">local max_permits = tonumber(rate_limit_info[3])</span><br><span class="line">local rate = rate_limit_info[4]</span><br><span class="line">local apps = rate_limit_info[5]</span><br><span class="line">--- 标识没有配置令牌桶</span><br><span class="line">if type(apps) == &apos;boolean&apos; or apps == nil or string.find(apps, context, 1)~=nil  then</span><br><span class="line">redis.pcall(&quot;HSET&quot;, key, &quot;apps&quot;, context)</span><br><span class="line">apps=context</span><br><span class="line">end</span><br><span class="line">if type(rate) == &apos;boolean&apos; or rate == nil then</span><br><span class="line">redis.pcall(&quot;HSET&quot;, key, &quot;rate&quot;, &quot;0.2&quot;)</span><br><span class="line">rate=0.2</span><br><span class="line">end</span><br><span class="line">if type(curr_permits) == &apos;boolean&apos; or curr_permits == nil then</span><br><span class="line">redis.pcall(&quot;HSET&quot;, key, &quot;curr_permits&quot;, &quot;0&quot;)</span><br><span class="line">end</span><br><span class="line">local local_curr_permits = max_permits;</span><br><span class="line">--- 令牌桶刚刚创建，上一次获取令牌的毫秒数为空</span><br><span class="line">--- 根据和上一次向桶里添加令牌的时间和当前时间差，触发式往桶里添加令牌</span><br><span class="line">--- 并且更新上一次向桶里添加令牌的时间</span><br><span class="line">--- 如果向桶里添加的令牌数不足一个，则不更新上一次向桶里添加令牌的时间</span><br><span class="line">if (type(last_mill_second) ~= &apos;boolean&apos; and last_mill_second ~= false and last_mill_second ~= nil) then</span><br><span class="line">local reverse_permits = math.floor(((curr_mill_second - last_mill_second) / 1000) * rate)</span><br><span class="line">local expect_curr_permits = reverse_permits + curr_permits;</span><br><span class="line">local_curr_permits = math.min(expect_curr_permits, max_permits);</span><br><span class="line">--- 大于0表示不是第一次获取令牌，也没有向桶里添加令牌</span><br><span class="line">if (reverse_permits &gt; 0) then</span><br><span class="line">redis.pcall(&quot;HSET&quot;, key, &quot;last_mill_second&quot;, curr_mill_second)</span><br><span class="line">end</span><br><span class="line">else</span><br><span class="line">redis.pcall(&quot;HSET&quot;, key, &quot;last_mill_second&quot;, curr_mill_second)</span><br><span class="line">end</span><br><span class="line">local result = -1</span><br><span class="line">if (local_curr_permits - permits &gt;= 0) then</span><br><span class="line">result = 1</span><br><span class="line">redis.pcall(&quot;HSET&quot;, key, &quot;curr_permits&quot;, local_curr_permits - permits)</span><br><span class="line">else</span><br><span class="line">redis.pcall(&quot;HSET&quot;, key, &quot;curr_permits&quot;, local_curr_permits)</span><br><span class="line">end</span><br><span class="line">return result</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">return acquire(KEYS[1],tonumber(KEYS[2]),tonumber(KEYS[3]),KEYS[4])</span><br></pre></td></tr></table></figure><p><img src="D:\develop\Workspaces\blog\source\_posts\image\Java架构班课程大纲.png" alt="Java架构班课程大纲"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一-”两窗两桶“限流算法&quot;&gt;&lt;a href=&quot;#一-”两窗两桶“限流算法&quot; class=&quot;headerlink&quot; title=&quot;一 ”两窗两桶“限流算法&quot;&gt;&lt;/a&gt;一 ”两窗两桶“限流算法&lt;/h3&gt;&lt;h4 id=&quot;1、固定窗口&quot;&gt;&lt;a href=&quot;#1、固定窗口&quot;
      
    
    </summary>
    
    
      <category term="限流,固定窗口,滑动窗口,漏桶,令牌桶" scheme="https://yzlit.github.io/tags/%E9%99%90%E6%B5%81-%E5%9B%BA%E5%AE%9A%E7%AA%97%E5%8F%A3-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3-%E6%BC%8F%E6%A1%B6-%E4%BB%A4%E7%89%8C%E6%A1%B6/"/>
    
  </entry>
  
</feed>
