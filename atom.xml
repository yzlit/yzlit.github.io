<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>酒夜狸个人博客</title>
  
  <subtitle>酒夜狸的个人博客，欢迎探讨有关编程，诗歌，科幻，人生。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yzlit.gitee.io/"/>
  <updated>2019-10-18T13:00:56.817Z</updated>
  <id>http://yzlit.gitee.io/</id>
  
  <author>
    <name>酒夜狸</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>千万流量RPC架构长啥样</title>
    <link href="http://yzlit.gitee.io/2019/01/19/%E5%8D%83%E4%B8%87%E6%B5%81%E9%87%8FRPC%E6%9E%B6%E6%9E%84%E9%95%BF%E5%95%A5%E6%A0%B7/"/>
    <id>http://yzlit.gitee.io/2019/01/19/千万流量RPC架构长啥样/</id>
    <published>2019-01-19T12:52:41.000Z</published>
    <updated>2019-10-18T13:00:56.817Z</updated>
    
    <content type="html"><![CDATA[<p>先举个例子感受一下千万级到底是什么数量级？现在很流行的优步(Uber)，从媒体公布的信息看，它每天接单量平均在百万左右， 假如每天有10个小时的服务时间，平均QPS只有30左右。对于一个后台服务器，单机的平均QPS可以到达800-1000，单独看写的业务量很简单 。为什么我们又不能说轻视它？第一，我们看它的数据存储，每天一百万的话，一年数据量的规模是多少？其次，刚才说的订单量，每一个订单要推送给附近的司机、司机要并<br>发抢单，后面业务场景的访问量往往是前者的上百倍，轻松就超过上亿级别了。</p><p>今天我想从架构的本质谈起之后，希望大家理解在做一些建构设计的时候，它的出发点以及它解决的问题是什么。</p><p>架构，刚开始的解释是我从知乎上看到的。什么是架构？有人讲， 说架构并不是一 个很 悬 乎的 东西 ， 实际 上就是一个架子 ， 放一些 业务 和算法，跟我们的生活中的晾衣架很像。更抽象一点，说架构其 实 是 对 我 们 重复性业务 的抽象和我 们 未来 业务 拓展的前瞻，强调过去的经验和你对整个行业的预见。</p><p>我们要想做一个架构的话需要哪些能力？我觉得最重要的是架构师一个最重要的能力就是你要有 战 略分解能力。这个怎么来看呢:</p><p>第一，你必须要有抽象的能力，抽象的能力最基本就是去重，去重在整个架构中体现在方方面面，从定义一个函数，到定义一个类，到提供的一个服务，以及模板，背后都是要去重提高可复用率。<br>第二， 分类能力。做软件需要做对象的解耦，要定义对象的属性和方法，做分布式系统的时候要做服务的拆分和模块化，要定义服务的接口和规范。<br>第三， 算法（性能），它的价值体现在提升系统的性能，所有性能的提升，最终都会落到CPU，内存，IO和网络这4大块上。</p><p><img src="pic\510-20151215135442334-1883091089.png" alt=""></p><p>这一页PPT举了一些例子来更深入的理解常见技术背后的架构理念。</p><ul><li>第一个例子，在分布式系统我们会做 MySQL分 库 分表，我们要从不同的库和表中读取数据，这样的抽象最直观就是使用模板，因为绝大多数SQL语义是相同的，除了路由到哪个库哪个表，如果不使用Proxy中间件，模板就是性价比最高的方法。</li><li>第二看一下加速网络的CDN，它是做速度方面的性能提升，刚才我们也提到从CPU、内存、IO、网络四个方面来考虑，CDN本质上一个是做网络智能调度优化，另一个是多级缓存优化。</li><li>第三个看一下服务化，刚才已经提到了，各个大网站转型过程中一定会做服务化，其实它就是做抽象和做服务的拆分。第四个看一下消息队列，本质上还是做分类，只不过不是两个边际清晰的类，而是把两个边际不清晰的子系统通过队列解构并且异步化。</li></ul><p><img src="pic\510-20151215135443177-443645586.png" alt=""></p><p><strong>新浪微博整体架构是什么样的</strong></p><p>接下我们看一下微博整体架构，到一定量级的系统整个架构都会变成三层，客户端包括WEB、安卓和IOS，这里就不说了。<br>接着还都会有一个接口层， 有三个主要作用：</p><ul><li>第一个作用，要做 安全隔离，因为前端节点都是直接和用户交互，需要防范各种恶意攻击；</li><li>第二个还充当着一个 流量控制的作用，大家知道，在2014年春节的时候，微信红包，每分钟8亿多次的请求，其实真正到它后台的请求量，只有十万左右的数量级（这里的数据可能不准），剩余的流量在接口层就被挡住了；</li><li>第三，我们看对 PC 端和移 动 端的需求不一样的，所以我们可以进行拆分。接口层之后是后台，可以看到微博后台有三大块：</li><li>一个是 平台服 务，</li><li>第二， 搜索，</li><li>第三， 大数据。<br>到了后台的各种服务其实都是处理的数据。 像平台的业务部门，做的就是 数据存储和读 取，对搜索来说做的是 数据的 检 索，对大数据来说是做的数据的 挖掘。微博其实和淘宝是很类似</li></ul><p><img src="pic\510-20151215135444271-98073581.png" alt=""></p><p>微博其实和淘宝是很类似的。一般来说，第一代架构，基本上能支撑到用户到 百万 级别，到第二代架构基本能支撑到 千万 级别都没什么问题，当业务规模到 亿级别时，需要第三代的架构。</p><p>从 LAMP 的架构到面向服 务 的架构，有几个地方是非常难的，首先不可能在第一代基础上通过简单的修修补补满足用户量快速增长的，同时线上业务又不能停， 这是我们常说的 在 飞 机上 换 引擎的 问题。前两天我有一个朋友问我，说他在内部推行服务化的时候，把一个模块服务化做完了，其他部门就是不接。我建议在做服务化的时候，首先更多是偏向业务的梳理，同时要找准一个很好的切入点，既有架构和服务化上的提升，业务方也要有收益，比如提升性能或者降低维护成本同时升级过程要平滑，建议开始从原子化服务切入，比如基础的用户服务， 基础的短消息服务，基础的推送服务。 第二，就是可 以做无状 态 服 务，后面会详细讲，还有数据量大了后需要做数据Sharding，后面会将。 第三代 架构 要解决的 问题，就是用户量和业务趋于稳步增加（相对爆发期的指数级增长），更多考虑技术框架的稳定性， 提升系统整体的性能，降低成本，还有对整个系统监控的完善和升级。</p><p><strong>大型网站的系统架构是如何演变的</strong></p><p>我们通过通过数据看一下它的挑战，PV是在10亿级别，QPS在百万，数据量在千亿级别。我们可用性，就是SLA要求4个9，接口响应最多不能超过150毫秒，线上所有的故障必须得在5分钟内解决完。如果说5分钟没处理呢？那会影响你年终的绩效考核。2015年微博DAU已经过亿。我们系统有上百个微服务，每周会有两次的常规上线和不限次数的紧急上线。我们的挑战都一样，就是数据量，bigger and bigger，用户体验是faster and faster，业务是more and more。互联网业务更多是产品体验驱动， 技 术 在 产 品 体验上最有效的贡献 ， 就是你的性能 越来越好 。 每次降低加载一个页面的时间，都可以间接的降低这个页面上用户的流失率。</p><p><img src="pic\510-20151215135447349-1250900543.png" alt=""></p><p><strong>微博的技术挑战和正交分解法解析架构</strong></p><p>下面看一下 第三代的 架构 图 以及 我 们 怎么用正交分解法 阐 述。 我们可以看到我们从两个维度，横轴和纵轴可以看到。 一个 维 度 是 水平的 分层 拆分，第二从垂直的维度会做拆分。水平的维度从接口层、到服务层到数据存储层。垂直怎么拆分，会用业务架构、技术架构、监控平台、服务治理等等来处理。我相信到第二代的时候很多架构已<br>经有了业务架构和技术架构的拆分。我们看一下， 接口层有feed、用户关系、通讯接口；服务层，SOA里有基层服务、原子服务和组合服务，在微博我们只有原子服务和组合服务。原子服务不依赖于任何其他服务，组合服务由几个原子服务和自己的业务逻辑构建而成 ，资源层负责海量数据的存储（后面例子会详细讲）。技 术框架解决 独立于 业务 的海量高并发场景下的技术难题，由众多的技术组件共同构建而成 。在接口层，微博使用JERSY框架，帮助你做参数的解析，参数的验证，序列化和反序列化；资源层，主要是缓存、DB相关的各类组件，比如Cache组件和对象库组件。监 控平台和服 务 治理 ， 完成系统服务的像素级监控，对分布式系统做提前诊断、预警以及治理。包含了SLA规则的制定、服务监控、服务调用链监控、流量监控、错误异常监控、线上灰度发布上线系统、线上扩容缩容调度系统等。</p><p><img src="pic\510-20151215135448334-1468907707.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;先举个例子感受一下千万级到底是什么数量级？现在很流行的优步(Uber)，从媒体公布的信息看，它每天接单量平均在百万左右， 假如每天有10个小时的服务时间，平均QPS只有30左右。对于一个后台服务器，单机的平均QPS可以到达800-1000，单独看写的业务量很简单 。为什么我
      
    
    </summary>
    
    
      <category term="RPC 高并发" scheme="http://yzlit.gitee.io/tags/RPC-%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java后台开发的修仙之路</title>
    <link href="http://yzlit.gitee.io/2019/01/13/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9A%84%E4%BF%AE%E4%BB%99%E4%B9%8B%E8%B7%AF/"/>
    <id>http://yzlit.gitee.io/2019/01/13/后台开发的修仙之路/</id>
    <published>2019-01-13T15:59:37.000Z</published>
    <updated>2019-10-17T14:25:17.227Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、基础"><a href="#一、基础" class="headerlink" title="一、基础"></a>一、基础</h3><p>这个阶段无他，多尝试，多学习，熟悉各种基础，对技术广度要有一定追求。</p><p>1，语言基础 </p><p>Java （以及其他语言Python，Go和一些前端涉略html Javascript）语法及语言特性</p><p>代码量要不断累积，主要是为了熟悉。</p><p>2，数据结构 </p><p>数组，链表，树，图， 以及排序算法</p><p>3，linux命令 </p><p>4，数据库</p><p>基础理论，sql语句，各种常用的数据库mysql mongodb redis memcache </p><p>5，计算机网络 TCP UDP OSI  MTU等等基础</p><p>6，设计模式</p><p>工厂，原型，生成器，等等</p><p>7，项目经验</p><p>主要对一些SSM，netty等等框架的应用到个人项目中，有一定的实战经验。</p><h3 id="二、进阶"><a href="#二、进阶" class="headerlink" title="二、进阶"></a>二、进阶</h3><p>这个阶段是脱离基础阶段只会用的程度，上升到知道为什么，以及具有活用到实际开发的能力，还要多多阅读源码，深入底层。</p><p>1，jvm虚拟机以及语言库的实现源码和原理：常见hashmap,table，concurrrentHashmap等等基本库。</p><p>2，算法：leetcode,剑指offer （ACM看个人吧）</p><p>3，linux操作系统底层原理</p><p>4，数据库原理，调优，（mysql mongodb redis memcache ）</p><p>5，spring SpringMVC mybatis ,netty等基本框架的源码解析，注意源码的框架思路，设计模式</p><h3 id="三、架构"><a href="#三、架构" class="headerlink" title="三、架构"></a>三、架构</h3><p>1，通信框架 netty websocket </p><p>2，其他中间件nginx,zookeeper,消息队列(rabbitmq，kafka,acctiveMQ)，docker。</p><p>3，数据库高可用架构 搜索数据库ES  大数据数据库Hbase</p><p>4,架构师个人非技术的修养 程序员的自我修养 代码之道 Head to Java First 等书</p><p><strong>最后送给自己一句话：「</strong></p><p><strong>你会的东西，有没有价值？你有没有把写代码的严谨和真实用到为人处事上面，有没有把和自己死磕的精神用到工作里面去。<br>如果没有，那你不要说你努力了。<br>」</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、基础&quot;&gt;&lt;a href=&quot;#一、基础&quot; class=&quot;headerlink&quot; title=&quot;一、基础&quot;&gt;&lt;/a&gt;一、基础&lt;/h3&gt;&lt;p&gt;这个阶段无他，多尝试，多学习，熟悉各种基础，对技术广度要有一定追求。&lt;/p&gt;
&lt;p&gt;1，语言基础 &lt;/p&gt;
&lt;p&gt;Java 
      
    
    </summary>
    
    
      <category term="后台开发,Java" scheme="http://yzlit.gitee.io/tags/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91-Java/"/>
    
  </entry>
  
  <entry>
    <title>Redis使用笔记</title>
    <link href="http://yzlit.gitee.io/2019/01/13/redis%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"/>
    <id>http://yzlit.gitee.io/2019/01/13/redis使用笔记/</id>
    <published>2019-01-13T04:23:55.000Z</published>
    <updated>2019-03-19T09:03:52.606Z</updated>
    
    <content type="html"><![CDATA[<h3 id="I-Redis持久化的方式有两种："><a href="#I-Redis持久化的方式有两种：" class="headerlink" title="I Redis持久化的方式有两种："></a>I Redis持久化的方式有两种：</h3><p>​    1.RDB:对内存中数据库状态进行快照<br>​    2.AOF:把每条写命令都写入文件，类似于mysql的binlog日志<br>​    </p><h4 id="一、-RDB方式："><a href="#一、-RDB方式：" class="headerlink" title="一、 RDB方式："></a>一、 RDB方式：</h4><p>将Redis在内存中的数据库状态保存到磁盘里面，RDB文件是一个经过</p><p>压缩的二进制文件，通过该文件可以还原生成RDB文件的数据状态。<br>  RDB的生成方式：</p><h5 id="1-指向命令手动生成"><a href="#1-指向命令手动生成" class="headerlink" title="1.指向命令手动生成"></a>1.指向命令手动生成</h5><p>​    有两个Redis命令可以生成RDB文件，一个是SAVE，另一个是BGSAVE，SAVE </p><p>命令会阻塞Redis服务器进程，知道RDB文件创建完毕为止，在服务器阻塞期间,服</p><p>务器不能处理任何的进程,BGSAVE会派出一个子进程，然后由子进程负责创建RDB</p><p>文件，服务器进程（父进程）继续处理命令请求，创建RDB文件结束之前，客户端</p><p>发送的 BGSAVE 和 SAVE 命令会被服务器拒绝</p><h5 id="2-通过配置自动生成"><a href="#2-通过配置自动生成" class="headerlink" title="2.通过配置自动生成"></a>2.通过配置自动生成</h5><p>​    可以设置服务器配置的save选项，让服务器每隔一段时间自动执行一次BGSAVE命令，可以通过save选项设置多个保存条件，但只要其中任意一个条件被满足就会执行BGSAGE命令<br>​    列如：<br>​    save 900 1<br>​    save 300 10<br>​    save 60  10000<br>​    那么只要满足以下三个条件中的其中一个，BGSAVE命令就会被执行<br>​    服务器在 900 秒之内，对数据库进行了 1 次修改<br>​    服务器在 300 秒之内，对数据库进行了 10 次修改<br>​    服务器在 900 秒之内，对数据库进行了 10000 次修改</p><h4 id="二，AOF方式："><a href="#二，AOF方式：" class="headerlink" title="二，AOF方式："></a>二，AOF方式：</h4><p>是通过保存Redis服务器所执行的写命令来记录数据库状态的AOF文件刷新方式，有三种：<br>    1.appendfsync always –每提交一个修改命令都调用fsync到AOF文件，非常慢，但是很安全；<br>    2.appendfsync everysec–每秒都调用fsyns刷新到AOF文件，很快但可能丢失一秒内的数据；<br>    3.appendfsync no–依靠OS进行刷新，redis不主动刷新AOF，这样最快但是安全性差；<br>    默认并且推荐每秒刷新，这样在速度和安全上都做到了兼顾<br>    配置如下<br>    appendonly yes #启用AOF<br>    appendfilename appendonly.aof #AOF文件的名称</p><pre><code># appendfsync alwaysappendfsync everysec #每秒钟强制写入磁盘一次# appendfsync no  </code></pre><h3 id="II-数据恢复"><a href="#II-数据恢复" class="headerlink" title="II 数据恢复"></a>II 数据恢复</h3><h4 id="1-ROB方式"><a href="#1-ROB方式" class="headerlink" title="1.ROB方式"></a>1.ROB方式</h4><p>​    ROB文件的载入工作是在服务器启动时自动执行的，没有专门用于载入ROB文件命令，只要Redis服务器再启动时检测到ROB文件存在，它就会自动载入ROB的文件，在服务器载入的期间，会一直处于阻塞状态，知道载入工作完成为止</p><h4 id="2-AOF方式"><a href="#2-AOF方式" class="headerlink" title="2.AOF方式"></a>2.AOF方式</h4><p>​    服务器在启动时，通过载入和执行AOF文件中保存的命令来还原服务器关闭之前的数据，具体库状态过程：<br>​        载入AOF文件<br>​        创建模拟客户端<br>​        从AOF文件中读取一条命令<br>​        使用模拟客户端执行命令<br>​        循环读取并执行命令，知道全部完成</p><p>   注意：如果同时启动了AOF和ROB方式，AOF优先，启动时只加载AOF文件恢复数时之加载</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;I-Redis持久化的方式有两种：&quot;&gt;&lt;a href=&quot;#I-Redis持久化的方式有两种：&quot; class=&quot;headerlink&quot; title=&quot;I Redis持久化的方式有两种：&quot;&gt;&lt;/a&gt;I Redis持久化的方式有两种：&lt;/h3&gt;&lt;p&gt;​    1.RDB
      
    
    </summary>
    
    
      <category term="Redis" scheme="http://yzlit.gitee.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>数据库ACID特性和事务</title>
    <link href="http://yzlit.gitee.io/2019/01/13/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7%E5%8F%8A%E4%BA%8B%E5%8A%A1/"/>
    <id>http://yzlit.gitee.io/2019/01/13/数据库四大特性及事务/</id>
    <published>2019-01-13T04:23:55.000Z</published>
    <updated>2019-03-14T13:47:39.586Z</updated>
    
    <content type="html"><![CDATA[<p>ACID特性<br>原子性<br>原子性是指数据库事务时不可分割的工作单位。只有使实物中所有的数据库操作都执行成功，才算整个事务成功。事务中任何一个SQL语句执行失败，已经执行成功的SQL语句也必须撤销，退回到事务前的状态。</p><p>一致性<br>事务将数据库从一种状态转变为下一种一致的状态。在事务开始之前和事务结束之后，数据库的完整性约束没有被破坏。</p><p>隔离性<br>每个读写事务的对象对其他事务的操作对象相互分离，即该事务提交前对其他事务都不可见，通常使用锁来实现。</p><p>持久性 </p><h2 id="事务一旦提交，其结果就是永久性的。及时发送宕机等故障，数据库也能将数据恢复。"><a href="#事务一旦提交，其结果就是永久性的。及时发送宕机等故障，数据库也能将数据恢复。" class="headerlink" title="事务一旦提交，其结果就是永久性的。及时发送宕机等故障，数据库也能将数据恢复。"></a>事务一旦提交，其结果就是永久性的。及时发送宕机等故障，数据库也能将数据恢复。</h2><p>作者：YinXinLion<br>来源：CSDN<br>原文：<a href="https://blog.csdn.net/qq_27602093/article/details/77069765" target="_blank" rel="noopener">https://blog.csdn.net/qq_27602093/article/details/77069765</a><br>版权声明：本文为博主原创文章，转载请附上博文链接！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ACID特性&lt;br&gt;原子性&lt;br&gt;原子性是指数据库事务时不可分割的工作单位。只有使实物中所有的数据库操作都执行成功，才算整个事务成功。事务中任何一个SQL语句执行失败，已经执行成功的SQL语句也必须撤销，退回到事务前的状态。&lt;/p&gt;
&lt;p&gt;一致性&lt;br&gt;事务将数据库从一种状
      
    
    </summary>
    
    
      <category term="跨域访问" scheme="http://yzlit.gitee.io/tags/%E8%B7%A8%E5%9F%9F%E8%AE%BF%E9%97%AE/"/>
    
  </entry>
  
  <entry>
    <title>工作之后如何处理好工作和学习的平衡</title>
    <link href="http://yzlit.gitee.io/2019/01/13/%E8%B0%88%E8%B0%88%E5%B7%A5%E4%BD%9C%E6%80%8E%E4%B9%88%E6%8F%90%E5%8D%87%E8%87%AA%E5%B7%B1%E7%9A%84%E8%AE%A1%E5%88%92/"/>
    <id>http://yzlit.gitee.io/2019/01/13/谈谈工作怎么提升自己的计划/</id>
    <published>2019-01-13T04:23:55.000Z</published>
    <updated>2019-10-17T15:31:08.973Z</updated>
    
    <content type="html"><![CDATA[<h5 id="一，工作"><a href="#一，工作" class="headerlink" title="一，工作"></a>一，工作</h5><p>首先最重要肯定是饭碗，对于大多数人来说，先维持一份薪水还过得去的工作，才能有力气去继续奔跑。</p><p>工作当然是枯燥的，CRUD的工作对于很多初级后台开发来说是常事，但是工作仍要做好，做出彩，如果你连工作最基本的都不肯做好，那么你又怎么可能去做好别的事，没有基本的工作，兴趣更是无从谈起。  </p><p>要做好工作 ，做出彩，也是要下很大努力的。</p><p>第一个就是要注意改进工作方法，提高工作效率。别因为自己的做事方法而耽误自己的时间，那是最蠢的。</p><p>工作方法首先是一句话，规划好工作量和工作计划，小步快跑。</p><p>规划很重要，不然你不知不觉浪费的时间，就是在慢慢把你拉进水里。</p><p>第二句话，懂得职场的规矩，每个公司都有不同的职场氛围，没有一模一样的处事方法，但是为人却是差不多，与人相处，要有诚意，也要保持礼貌，既要尽责地完成自己的工作，在不影响自己的工作和时间情况下，尽量给予帮助。</p><p>二，学习</p><p>工作了就不学习，过几个月你已经落后你的同学了，再过个一两年，公司把你炒了，你也找不到下家了。</p><p>学习，很重要，也要有规划，不能东学一个ES，西学一个微服务，三天打鱼式地刷几道leetcode。</p><p>要有规划，首先要计划时间，下班后从几点开始到睡觉前，要干什么，要学什么，进度怎么控制，怎么把学到的东西用起来，记下来。</p><p>生活和学习应该放在一起考虑，学习生活才是一种好的状态。</p><p>不荒废时光，学一些东西不在于你学了就行，而在于它能最大化提升你的价值，把你的时间花值了。</p><p>前路漫漫，坚持，方得始终。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;一，工作&quot;&gt;&lt;a href=&quot;#一，工作&quot; class=&quot;headerlink&quot; title=&quot;一，工作&quot;&gt;&lt;/a&gt;一，工作&lt;/h5&gt;&lt;p&gt;首先最重要肯定是饭碗，对于大多数人来说，先维持一份薪水还过得去的工作，才能有力气去继续奔跑。&lt;/p&gt;
&lt;p&gt;工作当然是枯燥的
      
    
    </summary>
    
    
      <category term="工作 学习" scheme="http://yzlit.gitee.io/tags/%E5%B7%A5%E4%BD%9C-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>跨域问题详解</title>
    <link href="http://yzlit.gitee.io/2019/01/13/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/"/>
    <id>http://yzlit.gitee.io/2019/01/13/跨域问题/</id>
    <published>2019-01-13T04:23:55.000Z</published>
    <updated>2019-01-13T11:09:27.913Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、什么是跨域？"><a href="#一、什么是跨域？" class="headerlink" title="一、什么是跨域？"></a>一、什么是跨域？</h3><p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1547370259736&amp;di=4a7c40b675fb2647cda6e5b6edacbef5&amp;imgtype=0&amp;src=http%3A%2F%2Fp.blog.csdn.net%2Fimages%2Fp_blog_csdn_net%2FPointer_v%2FEntryImages%2F20090212%2Fproxy2.gif" alt="img"></p><p>浏览器从一个域名的网页去请求另一个域名的资源时，域名、端口、协议任一不同，都是跨域。跨域访问会访问状态码200但是无法访问，还有其他附带的问题，请求COOKIE无法带上。</p><p>比如你从域名为120.258.45 的index.html要访问 156.85.14:8000/getaccess 接口，那么就会有跨域问题。一般尝试跨域访问就会出现No ‘Access-Control-Allow-Origin’ header is present on the requested resource.’ ，类似你可以从谷歌控制台，看到提示：</p><p><img src="https://img02.sogoucdn.com/app/a/100520146/3F0EA3D344F60FDDC77F5F96342D521D" alt=""></p><h3 id="二、为什么要禁止跨域访问"><a href="#二、为什么要禁止跨域访问" class="headerlink" title="二、为什么要禁止跨域访问"></a>二、为什么要禁止跨域访问</h3><p>这要涉及到浏览器的同源策略，同源策略限制了不同源之间的资源进行交互，用于隔离潜在的恶意文件的安全机制，并且是浏览器最基本的安全机制（同源：协议、域名、端口均相同，localhost和127.0.0.1也属于跨域）。</p><p>如果非同源，<strong>同源政策限制三种行为</strong>：</p><p>（1） Cookie、LocalStorage 和 IndexDB 无法读取。</p><p>（2） DOM 无法获得。</p><p>（3） AJAX 请求不能发送。</p><p>对于（1） Cookie、LocalStorage 和 IndexDB 无法读取，如果没有同源策略的限制，假设您进入一个受信网站A，输入了账号密码进行登录，服务器端验证通过后会在响应头中添加Set-Cookie字段，在下次访问时，浏览器就会将cookie附加在http请求头字段Cookie中，服务器就知道您已经登录过，下次你再带着这个cookie时访问受信网站A，服务器便不再验证了，如果在cookie信息还存在的情况下，您不小心访问另一个恶意钓鱼网站B，在您不知情的情况下向受信网站A发起了请求，这就相当于不法钓鱼网站登录了您的账户，可以为所欲为了！</p><p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1547370029724&amp;di=bb03e9658d9d929fedb977dfea332fa3&amp;imgtype=0&amp;src=http%3A%2F%2Faliyunzixunbucket.oss-cn-beijing.aliyuncs.com%2Fpng%2Fdd2d206d5afa78c483611418500872bc.png" alt="img"></p><p>对于（2） DOM 无法获得。又比如一个钓鱼网站，模仿银行网站A（没有了同源策略的限制，钓鱼网站就可以很轻松的网站A的DOM），诱导您输入账户密码信息，你的信息就没了，所以最近12306就是因为类似第三方的访问导致410万用户密码等信息泄漏。</p><p>对于（3） AJAX 请求不能发送同源政策规定，AJAX请求只能发给同源的网址，否则就报错。</p><p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1547370063925&amp;di=84fd25a37be6345294e3688294f5d791&amp;imgtype=0&amp;src=http%3A%2F%2F5b0988e595225.cdn.sohucs.com%2Fq_70%2Cc_zoom%2Cw_640%2Fimages%2F20180722%2F377baa2adfb34e04b15a80ec41554cdb.jpeg" alt="img"></p><h3 id="三、怎么解决跨域问题"><a href="#三、怎么解决跨域问题" class="headerlink" title="三、怎么解决跨域问题"></a>三、怎么解决跨域问题</h3><p>详细的同源策略通过前端解决的介绍可以看阮一峰的文章<br><a href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html</a></p><p>除了上述解决方法，服务端解决跨域会用到CORS，CORS是一个W3C标准，全称是”跨域资源共享“。详细的可以见阮一峰的文章<br><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/04/cors.html</a></p><h2 id="Nginx配置实例"><a href="#Nginx配置实例" class="headerlink" title="Nginx配置实例"></a>Nginx配置实例</h2><h3 id="实例一：允许example-com的应用在www-example2-com上跨域提取数据"><a href="#实例一：允许example-com的应用在www-example2-com上跨域提取数据" class="headerlink" title="实例一：允许example.com的应用在www.example2.com上跨域提取数据"></a>实例一：允许example.com的应用在<a href="http://www.example2.com上跨域提取数据" target="_blank" rel="noopener">www.example2.com上跨域提取数据</a></h3><p>在nginx.conf里找到server项,并在里面添加如下配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`location /&#123;` `add_header ``&apos;Access-Control-Allow-Origin&apos;` `&apos;http://example.com&apos;``;``add_header ``&apos;Access-Control-Allow-Credentials&apos;` `&apos;true&apos;``;``add_header ``&apos;Access-Control-Allow-Headers&apos;` `&apos;Authorization,Content-Type,Accept,Origin,User-Agent,DNT,Cache-Control,X-Mx-ReqToken,X-Requested-With&apos;``;``add_header ``&apos;Access-Control-Allow-Methods&apos;` `&apos;GET,POST,OPTIONS&apos;``;``...``&#125;`</span><br></pre></td></tr></table></figure><p>如果需要允许来自任何域的访问，可以这样配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`add_header Access-Control-Allow-Origin *;`</span><br></pre></td></tr></table></figure><p>注释如下</p><p>第一条指令：授权从example.com的请求(必需)</p><p>第二条指令：当该标志为真时，响应于该请求是否可以被暴露(可选)</p><p>第三条指令：允许脚本访问的返回头(可选)</p><p>第四条指令：指定请求的方法，可以是GET, POST, OPTIONS, PUT, DELETE等(可选)</p><p>重启Nginx</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`$ service nginx reload`</span><br></pre></td></tr></table></figure><p>测试跨域请求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`$ curl -I -X OPTIONS -H ``&quot;Origin: http://example.com&quot;` `http:``//www``.example2.com`</span><br></pre></td></tr></table></figure><p>成功时，响应头是如下所示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`HTTP``/1``.1 200 OK``Server: nginx``Access-Control-Allow-Origin: example.com`</span><br></pre></td></tr></table></figure><h3 id="实例二：Nginx允许多个域名跨域访问"><a href="#实例二：Nginx允许多个域名跨域访问" class="headerlink" title="实例二：Nginx允许多个域名跨域访问"></a>实例二：Nginx允许多个域名跨域访问</h3><p>由于Access-Control-Allow-Origin参数只允许配置单个域名或者 * ，当我们需要允许多个域名跨域访问时可以用以下几种方法来实现。</p><ul><li>方法一</li></ul><p>如需要允许用户请求来自<a href="http://www.example.com、m.example.com、wap.example.com访问www.example2.com域名时，返回头Access-Control-Allow-Origin，具体配置如下" target="_blank" rel="noopener">www.example.com、m.example.com、wap.example.com访问www.example2.com域名时，返回头Access-Control-Allow-Origin，具体配置如下</a></p><p>在nginx.conf里面,找到server项,并在里面添加如下配置</p><p>具体其他可看：<a href="https://www.cnblogs.com/sunmmi/articles/5956554.html" target="_blank" rel="noopener">https://www.cnblogs.com/sunmmi/articles/5956554.html</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`map $http_origin $corsHost &#123;``    ``default 0;``    ``&quot;~http://www.example.com&quot;` `http:``//www``.example.com;``    ``&quot;~http://m.example.com&quot;` `http:``//m``.example.com;``    ``&quot;~http://wap.example.com&quot;` `http:``//wap``.example.com;``&#125;` `server``&#123;``    ``listen 80;``    ``server_name www.example2.com;``    ``root ``/usr/share/nginx/html``;``    ``location /``    ``&#123;``        ``add_header Access-Control-Allow-Origin $corsHost;``    ``&#125;``&#125;`</span><br></pre></td></tr></table></figure><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="450" src="http://music.163.com/outchain/player?type=0&id=815573174&auto=0&height=430"><br></iframe><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="720" height="480" src="https://v.qq.com/txp/iframe/player.html?vid=v0825jzd59q" allowfullscreen="true"></iframe>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、什么是跨域？&quot;&gt;&lt;a href=&quot;#一、什么是跨域？&quot; class=&quot;headerlink&quot; title=&quot;一、什么是跨域？&quot;&gt;&lt;/a&gt;一、什么是跨域？&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://timgsa.baidu.com/timg?image&amp;
      
    
    </summary>
    
    
      <category term="跨域访问" scheme="http://yzlit.gitee.io/tags/%E8%B7%A8%E5%9F%9F%E8%AE%BF%E9%97%AE/"/>
    
  </entry>
  
  <entry>
    <title>mysql有关索引的一些总结</title>
    <link href="http://yzlit.gitee.io/2019/01/12/mysql%E7%B4%A2%E5%BC%95%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/"/>
    <id>http://yzlit.gitee.io/2019/01/12/mysql索引的一些总结/</id>
    <published>2019-01-12T15:46:47.000Z</published>
    <updated>2019-03-14T14:49:13.296Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、四大索引"><a href="#一、四大索引" class="headerlink" title="一、四大索引"></a>一、四大索引</h2><table><thead><tr><th style="text-align:center">索引类型</th><th style="text-align:center">适用范围</th><th style="text-align:center">不适用</th><th style="text-align:center">效率</th><th>引擎</th></tr></thead><tbody><tr><td style="text-align:center">全文索引(FULLTEXT)</td><td style="text-align:center">char,vachar,text列，用于like %word%</td><td style="text-align:center">中文支持不是很好，中文分词插件Mysqlcft，用Apache的Lucene替代</td><td style="text-align:center">低</td><td>MyISAM</td></tr><tr><td style="text-align:center">HASH</td><td style="text-align:center">= in &lt;=&gt;</td><td style="text-align:center">范围查询，排序，组合索引，无法避免表扫描</td><td style="text-align:center">需要遍历hash表</td><td>MEMORY</td></tr><tr><td style="text-align:center">B+树</td><td style="text-align:center">普遍适用</td><td style="text-align:center"></td><td style="text-align:center">与树结构有关</td><td>Innodb：1，primary key：主键+其他字段                        2，secondary index：只保存主键指针                   myISAM:叶子结点存放该数据的行指向</td></tr><tr><td style="text-align:center">R树</td><td style="text-align:center">geometry数据类型</td><td style="text-align:center">范围查找</td><td style="text-align:center"></td><td>MyISAM、BDb、InnoDb、NDb、Archive</td></tr></tbody></table><h2 id="二、有关于B树和B-树的区别"><a href="#二、有关于B树和B-树的区别" class="headerlink" title="二、有关于B树和B+树的区别"></a>二、有关于B树和B+树的区别</h2><ul><li>B树中关键字集合分布在整棵树中，叶节点中不包含任何关键字信息，而B+树关键字集合分布在叶子结点中，非叶节点只是叶子结点中关键字的索引；</li><li><p>B树中任何一个关键字只出现在一个结点中，而B+树中的关键字必须出现在叶节点中；</p></li><li><p>不同于B树只适合<strong>随机检索</strong>，B+树同时支持随机检索<strong>和顺序检索</strong>；</p></li><li>B+树的磁盘读写代价更低。B+树的<strong>内部结点并没有指向关键字具体信息的指针</strong>，其内部结点比B树小，盘块能容纳的结点中关键字数量更多，一次性读入内存中可以查找的关键字也就越多，相对的，IO读写次数也就降低了。而IO读写次数是影响索引检索效率的最大因素。</li><li>B+树的查询效率更加稳定。B树搜索有可能会在非叶子结点结束，越靠近根节点的记录查找时间越短，只要找到关键字即可确定记录的存在，其性能等价于在关键字全集内做一次二分查找。而在B+树中，顺序检索比较明显，随机检索时，任何关键字的查找都必须走一条从根节点到叶节点的路，所有关键字的查找路径长度相同，导致每一个关键字的查询效率相当。</li><li>数据库索引采用B+树的主要原因是，）B-树在提高了磁盘IO性能的同时并没有解决<strong>元素遍历的效率</strong>低下的问题。B+树的叶子节点使用指针顺序连接在一起，<strong>只要遍历叶子节点就可以实现整棵树的遍历</strong>。而且<strong>在数据库中基于范围的查询是非常频繁的</strong>，而B树不支持这样的操作（或者说效率太低）。</li></ul><h2 id="三、B-树比B树更适合做文件索引的原因"><a href="#三、B-树比B树更适合做文件索引的原因" class="headerlink" title="三、B+树比B树更适合做文件索引的原因"></a>三、B+树比B树更适合做文件索引的原因</h2><h5 id="（1）B-树空间利用率更高，可减少I-O次数，"><a href="#（1）B-树空间利用率更高，可减少I-O次数，" class="headerlink" title="（1）B+树空间利用率更高，可减少I/O次数，"></a>（1）B+树空间利用率更高，可减少I/O次数，</h5><p>​         一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗。而因为B+树的内部节点只是作为索引使用，而不像B-树那样每个节点都需要存储硬盘指针。<br>​         也就是说：B+树中每个非叶节点没有指向某个关键字具体信息的指针，所以每一个节点可以存放更多的关键字数量，即一次性读入内存所需要查找的关键字也就越多，减少了I/O操作。<br>​     e.g.假设磁盘中的一个盘块容纳16bytes，而一个关键字2bytes，一个关键字具体信息指针2bytes。一棵9阶B-tree(一个结点最多8个关键字)的内   部结点需要2个盘快。而B+ 树内部结点只需要1个盘快。当需要把内部结点读入内存中的时候，B 树就比B+ 树多一次盘块查找时间(在磁盘中就   是         盘片旋转的时间)。</p><h5 id="（2）增删文件（节点）时，效率更高，"><a href="#（2）增删文件（节点）时，效率更高，" class="headerlink" title="（2）增删文件（节点）时，效率更高，"></a><strong>（2）增删文件（节点）时，效率更高，</strong></h5><p>​         因为B+树的叶子节点包含所有关键字，并以有序的链表结构存储，这样可很好提高增删效率。</p><h5 id="（3）B-树的查询效率更加稳定，"><a href="#（3）B-树的查询效率更加稳定，" class="headerlink" title="（3）B+树的查询效率更加稳定，"></a><strong>（3）B+树的查询效率更加稳定，</strong></h5><p>​    因为B+树的每次查询过程中，都需要遍历从根节点到叶子节点的某条路径。所有关键字的查询路径长度相同，导致每一次查询的效率相当。</p><h2 id="四、索引失效的情况"><a href="#四、索引失效的情况" class="headerlink" title="四、索引失效的情况"></a>四、索引失效的情况</h2><p>1，不遵守最左原则</p><p>2， like</p><p>like ‘%xx’    select * from tb1 where name like ‘%cn’;</p><p>3 使用函数<br>select * from tb1 where reverse(name) = ‘wupeiqi’;</p><p>4,使用 or 时,or 条件中有未建立索引的列</p><p>select <em> from tb1 where nid = 1 or email = <a href="mailto:&#39;seven@live.com" target="_blank" rel="noopener">&#39;seven@live.com</a>‘;<br>特别的：当or条件中有未建立索引的列才失效，以下会走索引<br>        select </em> from tb1 where nid = 1 or name = ‘seven’;<br>        select * from tb1 where nid = 1 or email = <a href="mailto:&#39;seven@live.com" target="_blank" rel="noopener">&#39;seven@live.com</a>‘ and name = ‘alex’- 类型不一致<br>5，使用 ！=   &gt;</p><p>如果列是字符串类型，传入条件是必须用引号引起来<br>    特别的：如果是主键，则还是会走索引<br>    select <em> from tb1 where nid != 123   - &gt;    select </em> from tb1 where name &gt; ‘alex’</p><p>特别的：如果是主键或索引是整数类型，则还是会走索引<br>select * from tb1 where nid &gt; 123       </p><p>select * from tb1 where num &gt; 123- order by    </p><p>select email from tb1 order by name desc;</p><p>6 ,当根据索引排序时候，选择的映射如果不是索引，则不走索引</p><p>特别的：如果对主键排序，则还是走索引：<br>    select * from tb1 order by nid desc</p><h2 id="五、sql代码"><a href="#五、sql代码" class="headerlink" title="五、sql代码"></a>五、sql代码</h2><p>查看MySQL慢日志</p><p><code>mysqldumpslow -s at -a  /usr/local/`</code>var<code></code>/mysql/MacBook-Pro-3-slow.log`</p><p>全文索引</p><p>创建ALTER TABLE table ADD INDEX <code>FULLINDEX</code> USING FULLTEXT(<code>cname1</code>[,cname2…]);</p><p>使用SELECT * FROM table WHERE MATCH(cname1[,cname2…]) AGAINST (‘word’ MODE );</p><p>创建普通索引  </p><p>CREATE INDEX index_name ON table_name(col_name);</p><p>创建唯一索引</p><p>CREATE UNIQUE INDEX index_name ON table_name(col_name);</p><p>创建普通组合索引</p><p>CREATE INDEX index_name ON table_name(col_name_1,col_name_2);</p><p>创建唯一组合索引</p><p>CREATE UNIQUE INDEX index_name ON table_name(col_name_1,col_name_2);</p><p>通用</p><p>ALTER TABLE interface ADD FULLTEXT（INDEX） fullText_index(interfaceName);</p><p>直接删除索引</p><p>DROP INDEX index_name ON table_name;</p><p>–修改表结构删除索引</p><p>ALTER TABLE table_name DROP INDEX index_name;</p><p>六、 sql优化</p><p>1.Innerjoin和左连接，右连接，子查询</p><p>A.     inner join内连接也叫等值连接是，left/rightjoin是外连接。能用inner join连接尽量使用inner join连接</p><p>B．子查询的性能又比外连接性能慢，尽量用外连接来替换子查询。</p><p>C 使用JOIN时候，应该用小的表驱动大表，left join尽量左表小</p><p>D 尽量把牵涉到多表联合的查询拆分多个query(多个表查询效率低，容易锁表和阻塞)</p><p>详见：<a href="https://blog.csdn.net/heqinghua217/article/details/78600967" target="_blank" rel="noopener">https://blog.csdn.net/heqinghua217/article/details/78600967</a></p><p>2.建立索引,加快查询性能.</p><p>A，组合索引注意最左原则</p><p>B．保证连接表的索引是相同的类型，意思就是A表和B表相关联的字段，必须是同类型的。</p><p>C. 索引不会包含有NULL值的列</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、四大索引&quot;&gt;&lt;a href=&quot;#一、四大索引&quot; class=&quot;headerlink&quot; title=&quot;一、四大索引&quot;&gt;&lt;/a&gt;一、四大索引&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;索引类型&lt;/
      
    
    </summary>
    
    
      <category term="索引" scheme="http://yzlit.gitee.io/tags/%E7%B4%A2%E5%BC%95/"/>
    
      <category term="mysql" scheme="http://yzlit.gitee.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>从服务端来讲讲限流的思路</title>
    <link href="http://yzlit.gitee.io/2019/01/12/%E4%BB%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%9D%A5%E8%AE%B2%E8%AE%B2%E9%99%90%E6%B5%81%E7%9A%84%E6%80%9D%E8%B7%AF/"/>
    <id>http://yzlit.gitee.io/2019/01/12/从服务端来讲讲限流的思路/</id>
    <published>2019-01-12T15:46:47.000Z</published>
    <updated>2019-01-15T04:29:46.786Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-”两窗两桶“限流算法"><a href="#一-”两窗两桶“限流算法" class="headerlink" title="一 ”两窗两桶“限流算法"></a>一 ”两窗两桶“限流算法</h3><h4 id="1、固定窗口"><a href="#1、固定窗口" class="headerlink" title="1、固定窗口"></a>1、固定窗口</h4><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20181222/b991453cf5a74d4ba430f1be5ea6d776.jpg" alt="img"></p><p>固定窗口指的是为一定时间段的流量设置一个阈值，超过则触发限流策略（丢弃或者停留），然后直到下一个时间段重新置零开始计数，</p><p>这种策略很明显一个缺点是这个时间段的间隔要设置得好，否则会存在一个问题，就是无法“削峰填谷”，当时间间隔设为10秒100个请求量时，本来是应该正常每秒10个请求，但是突然第一秒就来了100个请求，在第一秒就变成100个请求每秒了，所以是没法达到限流缓冲的效果，所以这种策略比较粗暴简单。</p><p>「滑动窗口」可以改善上面的问题。</p><h4 id="2、滑动窗口"><a href="#2、滑动窗口" class="headerlink" title="2、滑动窗口"></a>2、滑动窗口</h4><p>滑动窗口算法 类似于我们学过TCP的滑动窗口，对固定窗口的一种优化。</p><p>滑动窗口就是对固定窗口做了进一步的细分，将原先的粒度切的更细，比如1分钟的固定窗口切分为60个1秒的滑动窗口。然后统计的时间范围随着时间的推移同步后移。</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20181222/e87df09d3ffd414f88a43c43d0423631.jpg" alt="img"></p><p>虽然说滑动窗口可以改善这个问题，但是本质上还是预先划定时间片的方式，属于一种“预测”，意味着几乎肯定无法做到100%的物尽其用。</p><p>问题在在于由于访问量的不可预见性，会发生单位时间的前半段大量请求涌入，而后半段则拒绝所有请求的情况。（通常，需要可以将单位时间切的足够的小来缓解 ）其次，我们很难确定这个阈值设置在多少比较合适，只能通过经验或者模拟（如压测）来进行估计，即使是压测也很难估计的准确。集群部署中每台机器的硬件参数不同，可能导致我们需要对每台机器的阈值设置的都不尽相同。同一台机子在不同的时间点的系统压力也不一样（比如晚上还有一些任务，或其他的一些业务操作的影响），能够承受的最大阈值也不尽相同，我们无法考虑的周全。 </p><p>所以滑窗模式通常适用于对某一资源的保护的需求上（或者说是承诺比较合适：我对某一接口的提供者承诺过，最高调用量不超过XX），如对db的保护，对某一服务的调用的控制上。  </p><h4 id="3，漏桶算法"><a href="#3，漏桶算法" class="headerlink" title="3，漏桶算法"></a>3，漏桶算法</h4><h4 id="4，令牌桶算法"><a href="#4，令牌桶算法" class="headerlink" title="4，令牌桶算法"></a>4，令牌桶算法</h4><h3 id="二、做「限流」的最佳实践"><a href="#二、做「限流」的最佳实践" class="headerlink" title="二、做「限流」的最佳实践"></a><strong>二、做「限流」的最佳实践</strong></h3><h4 id="1、四种策略该如何选择？"><a href="#1、四种策略该如何选择？" class="headerlink" title="1、四种策略该如何选择？"></a>1、四种策略该如何选择？</h4><p>首先，<strong>固定窗口</strong>。一般来说，如非时间紧迫，不建议选择这个方案，太过生硬。但是，为了能快速止损眼前的问题可以作为临时应急的方案。</p><p>其次，<strong>滑动窗口</strong>。这个方案适用于对异常结果「高容忍」的场景，毕竟相比“两窗”少了一个缓冲区。但是，胜在实现简单。</p><p>然后，<strong>漏桶</strong>。个人觉得这个方案最适合作为一个通用方案。虽说资源的利用率上不是极致，但是「宽进严出」的思路在保护系统的同时还留有一些余地，使得它的适用场景更广。</p><p>最后，<strong>令牌桶</strong>。当你需要尽可能的压榨程序的性能（此时桶的最大容量必然会大于等于程序的最大并发能力），并且所处的场景流量进入波动不是很大（不至于一瞬间取完令牌，压垮后端系统）。</p><h3 id="三、如何做分布式限流"><a href="#三、如何做分布式限流" class="headerlink" title="三、如何做分布式限流"></a>三、如何做分布式限流</h3><p>如果要分布式限流，那么单机限流的策略其实只需要移植一下，用新的工具如redis+lua 或者nginx+lua 又或者用zookeeper也是可以实现的，下面先具体讲讲redis+lua的分布式限流的思路和代码例子，其他有空再补上。</p><p>redis做限流的思路是先设置一个key=service1的记录，值为流量，和时间戳。这些用lua来主要是因为redis不支持事务，而lua脚本是作为一个原子操作一起执行的，lua脚本也是会存在reids内存中作为经常执行的命令串。</p><p>下面是固定窗口算法的lua脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">local key = KEYS[1]             </span><br><span class="line">local limit = tonumber(KEYS[2])   ## 限流</span><br><span class="line">local current = tonumber(redis.call(&apos;get&apos;, key) or 0)</span><br><span class="line"></span><br><span class="line">if current + 1 &gt; limit then</span><br><span class="line">    return 0</span><br><span class="line">else</span><br><span class="line">    redis.call(&quot;INCRBY&quot;, key,&quot;1&quot;)    ## 对key 加1操作</span><br><span class="line">    redis.call(&quot;EXPIRE&quot;, key,&quot;10&quot;)   ## 过期时间设为10秒</span><br><span class="line">    return 1</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>下面是令牌桶算法的lua脚本</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--- 获取令牌</span></span><br><span class="line"><span class="comment">--- 返回码</span></span><br><span class="line"><span class="comment">--- 0 没有令牌桶配置</span></span><br><span class="line"><span class="comment">--- -1 表示取令牌失败，也就是桶里没有令牌</span></span><br><span class="line"><span class="comment">--- 1 表示取令牌成功</span></span><br><span class="line"><span class="comment">--- @param key 令牌（资源）的唯一标识</span></span><br><span class="line"><span class="comment">--- @param permits 请求令牌数量</span></span><br><span class="line"><span class="comment">--- @param curr_mill_second 当前毫秒数</span></span><br><span class="line"><span class="comment">--- @param context 使用令牌的应用标识</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">acquire</span><span class="params">(key, permits, curr_mill_second, context)</span></span></span><br><span class="line"><span class="comment">---    设置令牌桶的容量为5</span></span><br><span class="line"><span class="comment">--    redis.pcall("HSET", key, "max_permits", "5")  ---桶令牌容量为5</span></span><br><span class="line"><span class="comment">--    redis.pcall("HSET", key, "apps", context)     ---设置要取的key为apps</span></span><br><span class="line"><span class="comment">--    redis.pcall("HSET", key, "rate", "0.2")       ---设置令牌桶每0.2秒增加一个令牌</span></span><br><span class="line"><span class="comment">--    redis.pcall("HSET", key, "curr_permits", "0") ---初始化零时刻时令牌桶的令牌数为0</span></span><br><span class="line"><span class="comment">--    这里可以交由可交由另外的脚本执行。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> rate_limit_info = redis.<span class="built_in">pcall</span>(<span class="string">"HMGET"</span>, key, <span class="string">"last_mill_second"</span>, <span class="string">"curr_permits"</span>, <span class="string">"max_permits"</span>, <span class="string">"rate"</span>, <span class="string">"apps"</span>)</span><br><span class="line"><span class="keyword">local</span> last_mill_second = rate_limit_info[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">local</span> curr_permits = <span class="built_in">tonumber</span>(rate_limit_info[<span class="number">2</span>])</span><br><span class="line"><span class="keyword">local</span> max_permits = <span class="built_in">tonumber</span>(rate_limit_info[<span class="number">3</span>])</span><br><span class="line"><span class="keyword">local</span> rate = rate_limit_info[<span class="number">4</span>]</span><br><span class="line"><span class="keyword">local</span> apps = rate_limit_info[<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">--- 如果没有初始化redis里的令牌桶信息，需要首次初始化令牌桶的一些信息</span></span><br><span class="line"><span class="comment">--if not apps or string.find(apps, context, 1)~=nil then</span></span><br><span class="line"><span class="comment">----- if type(apps) == 'boolean' or apps == nil   then</span></span><br><span class="line"><span class="comment">--redis.pcall("HSET", key, "apps", context)</span></span><br><span class="line"><span class="comment">--apps=context</span></span><br><span class="line"><span class="comment">--end</span></span><br><span class="line"><span class="comment">--if not rate then</span></span><br><span class="line"><span class="comment">--redis.pcall("HSET", key, "rate", "0.2")</span></span><br><span class="line"><span class="comment">--rate=0.2</span></span><br><span class="line"><span class="comment">--end</span></span><br><span class="line"><span class="comment">--if not curr_permits then</span></span><br><span class="line"><span class="comment">--redis.pcall("HSET", key, "curr_permits", "0")</span></span><br><span class="line"><span class="comment">--end</span></span><br><span class="line"><span class="comment">---初始化令牌桶完毕</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> local_curr_permits = max_permits;</span><br><span class="line"><span class="comment">--- 令牌桶刚刚创建，上一次获取令牌的毫秒数为空</span></span><br><span class="line"><span class="comment">--- 根据和上一次向桶里添加令牌的时间和当前时间差，触发式往桶里添加令牌</span></span><br><span class="line"><span class="comment">--- 并且更新上一次向桶里添加令牌的时间</span></span><br><span class="line"><span class="comment">--- 如果向桶里添加的令牌数不足一个，则不更新上一次向桶里添加令牌的时间</span></span><br><span class="line"><span class="comment">--- if (type(last_mill_second) ~= 'boolean' and last_mill_second ~= false and last_mill_second ~= nil) then</span></span><br><span class="line"><span class="comment">--- 桶有初始化 ，其实可以不用判断</span></span><br><span class="line"><span class="keyword">if</span> last_mill_second <span class="keyword">then</span></span><br><span class="line"><span class="keyword">local</span> reverse_permits = <span class="built_in">math</span>.<span class="built_in">floor</span>(((curr_mill_second - last_mill_second) / <span class="number">1000</span>) * rate)</span><br><span class="line"><span class="keyword">local</span> expect_curr_permits = reverse_permits + curr_permits;</span><br><span class="line">local_curr_permits = <span class="built_in">math</span>.<span class="built_in">min</span>(expect_curr_permits, max_permits);  <span class="comment">--- 这是此时此刻的桶令牌的数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--- 大于0表示令牌桶的数量不需要放入，因此时间戳也暂时不更新，等下一次令牌桶有增加时再更新</span></span><br><span class="line"><span class="keyword">if</span> (reverse_permits &gt; <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">redis.<span class="built_in">pcall</span>(<span class="string">"HSET"</span>, key, <span class="string">"last_mill_second"</span>, curr_mill_second)   <span class="comment">--- 更新时间戳</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">redis.<span class="built_in">pcall</span>(<span class="string">"HSET"</span>, key, <span class="string">"last_mill_second"</span>, curr_mill_second)  <span class="comment">--- 这是初始化后的步骤 启用令牌桶，设置时间戳</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">local</span> result = <span class="number">-1</span></span><br><span class="line"><span class="keyword">if</span> (local_curr_permits - permits &gt;= <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">result = <span class="number">1</span></span><br><span class="line">redis.<span class="built_in">pcall</span>(<span class="string">"HSET"</span>, key, <span class="string">"curr_permits"</span>, local_curr_permits - permits)  <span class="comment">--- 更新桶令牌的数量为拿走后剩下的数量</span></span><br><span class="line"><span class="comment">--else</span></span><br><span class="line"><span class="comment">--redis.pcall("HSET", key, "curr_permits", local_curr_permits)            --- 不需要更新桶令牌的数量</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> acquire(KEYS[<span class="number">1</span>],<span class="built_in">tonumber</span>(KEYS[<span class="number">2</span>]),<span class="built_in">tonumber</span>(KEYS[<span class="number">3</span>]),KEYS[<span class="number">4</span>])</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一-”两窗两桶“限流算法&quot;&gt;&lt;a href=&quot;#一-”两窗两桶“限流算法&quot; class=&quot;headerlink&quot; title=&quot;一 ”两窗两桶“限流算法&quot;&gt;&lt;/a&gt;一 ”两窗两桶“限流算法&lt;/h3&gt;&lt;h4 id=&quot;1、固定窗口&quot;&gt;&lt;a href=&quot;#1、固定窗口&quot;
      
    
    </summary>
    
    
      <category term="限流" scheme="http://yzlit.gitee.io/tags/%E9%99%90%E6%B5%81/"/>
    
      <category term="固定窗口" scheme="http://yzlit.gitee.io/tags/%E5%9B%BA%E5%AE%9A%E7%AA%97%E5%8F%A3/"/>
    
      <category term="滑动窗口" scheme="http://yzlit.gitee.io/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
      <category term="漏桶" scheme="http://yzlit.gitee.io/tags/%E6%BC%8F%E6%A1%B6/"/>
    
      <category term="令牌桶" scheme="http://yzlit.gitee.io/tags/%E4%BB%A4%E7%89%8C%E6%A1%B6/"/>
    
  </entry>
  
</feed>
