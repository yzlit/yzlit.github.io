<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="/atom.xml" title="酒夜狸个人博客" type="application/atom+xml">






<meta name="description" content="酒夜狸的个人博客，欢迎探讨有关编程，诗歌，科幻，人生。">
<meta name="keywords" content="酒夜狸 个人博客">
<meta property="og:type" content="website">
<meta property="og:title" content="酒夜狸个人博客">
<meta property="og:url" content="https://yzlit.github.io/index.html">
<meta property="og:site_name" content="酒夜狸个人博客">
<meta property="og:description" content="酒夜狸的个人博客，欢迎探讨有关编程，诗歌，科幻，人生。">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="酒夜狸个人博客">
<meta name="twitter:description" content="酒夜狸的个人博客，欢迎探讨有关编程，诗歌，科幻，人生。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://yzlit.github.io/">





  <title>酒夜狸个人博客</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">酒夜狸个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">酒夜狸的个人博客，欢迎探讨有关编程，诗歌，科幻，人生。</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yzlit.github.io/2019/01/19/千万流量RPC架构长啥样/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="酒夜狸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="酒夜狸个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/19/千万流量RPC架构长啥样/" itemprop="url">千万流量RPC架构长啥样</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-19T20:52:41+08:00">
                2019-01-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yzlit.github.io/2019/01/13/后台开发的修仙之路/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="酒夜狸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="酒夜狸个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/13/后台开发的修仙之路/" itemprop="url">Java后台开发的修仙之路</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-13T23:59:37+08:00">
                2019-01-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="一、基础"><a href="#一、基础" class="headerlink" title="一、基础"></a>一、基础</h3><p>这个阶段无他，多尝试，多学习，熟悉各种基础，对技术广度要有一定追求。</p>
<p>1，语言基础 </p>
<p>Java （以及其他语言Python，Go和一些前端涉略html Javascript）语法及语言特性</p>
<p>代码量要不断累积，主要是为了熟悉。</p>
<p>2，数据结构 </p>
<p>数组，链表，树，图， 以及排序算法</p>
<p>3，linux命令 </p>
<p>4，数据库</p>
<p>基础理论，sql语句，各种常用的数据库mysql mongodb redis memcache </p>
<p>5，计算机网络 TCP UDP OSI  MTU等等基础</p>
<p>6，设计模式</p>
<p>工厂，原型，生成器，等等</p>
<p>7，项目经验</p>
<p>主要对一些SSM，netty等等框架的应用到个人项目中，有一定的实战经验。</p>
<h3 id="二、进阶"><a href="#二、进阶" class="headerlink" title="二、进阶"></a>二、进阶</h3><p>这个阶段是脱离基础阶段只会用的程度，上升到知道为什么，以及具有活用到实际开发的能力，还要多多阅读源码，深入底层。</p>
<p>1，jvm虚拟机以及语言库的实现源码和原理：常见hashmap,table，concurrrentHashmap等等基本库。</p>
<p>2，算法：leetcode,剑指offer （ACM看个人吧）</p>
<p>3，linux操作系统底层原理</p>
<p>4，数据库原理，调优，（mysql mongodb redis memcache ）</p>
<p>5，spring SpringMVC mybatis ,netty等基本框架的源码解析，注意源码的框架思路，设计模式</p>
<h3 id="三、架构"><a href="#三、架构" class="headerlink" title="三、架构"></a>三、架构</h3><p>1，通信框架 netty websocket </p>
<p>2，其他中间件nginx,zookeeper,消息队列(rabbitmq，kafka,acctiveMQ)，docker。</p>
<p>3，数据库高可用架构 搜索数据库ES  大数据数据库Hbase</p>
<p>4,架构师个人非技术的修养 程序员的自我修养 代码之道 Head to Java First 等书</p>
<p><strong>最后送给自己一句话：「</strong></p>
<p><strong>你会的东西，有没有价值？你有没有把写代码的严谨和真实用到为人处事上面，有没有把和自己死磕的精神用到工作里面去。<br>如果没有，那你不要说你努力了。<br>」</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yzlit.github.io/2019/01/13/redis使用笔记/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="酒夜狸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="酒夜狸个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/13/redis使用笔记/" itemprop="url">Redis使用笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-13T12:23:55+08:00">
                2019-01-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="I-Redis持久化的方式有两种："><a href="#I-Redis持久化的方式有两种：" class="headerlink" title="I Redis持久化的方式有两种："></a>I Redis持久化的方式有两种：</h3><p>​    1.RDB:对内存中数据库状态进行快照<br>​    2.AOF:把每条写命令都写入文件，类似于mysql的binlog日志<br>​    </p>
<h4 id="一、-RDB方式："><a href="#一、-RDB方式：" class="headerlink" title="一、 RDB方式："></a>一、 RDB方式：</h4><p>将Redis在内存中的数据库状态保存到磁盘里面，RDB文件是一个经过</p>
<p>压缩的二进制文件，通过该文件可以还原生成RDB文件的数据状态。<br>  RDB的生成方式：</p>
<h5 id="1-指向命令手动生成"><a href="#1-指向命令手动生成" class="headerlink" title="1.指向命令手动生成"></a>1.指向命令手动生成</h5><p>​    有两个Redis命令可以生成RDB文件，一个是SAVE，另一个是BGSAVE，SAVE </p>
<p>命令会阻塞Redis服务器进程，知道RDB文件创建完毕为止，在服务器阻塞期间,服</p>
<p>务器不能处理任何的进程,BGSAVE会派出一个子进程，然后由子进程负责创建RDB</p>
<p>文件，服务器进程（父进程）继续处理命令请求，创建RDB文件结束之前，客户端</p>
<p>发送的 BGSAVE 和 SAVE 命令会被服务器拒绝</p>
<h5 id="2-通过配置自动生成"><a href="#2-通过配置自动生成" class="headerlink" title="2.通过配置自动生成"></a>2.通过配置自动生成</h5><p>​    可以设置服务器配置的save选项，让服务器每隔一段时间自动执行一次BGSAVE命令，可以通过save选项设置多个保存条件，但只要其中任意一个条件被满足就会执行BGSAGE命令<br>​    列如：<br>​    save 900 1<br>​    save 300 10<br>​    save 60  10000<br>​    那么只要满足以下三个条件中的其中一个，BGSAVE命令就会被执行<br>​    服务器在 900 秒之内，对数据库进行了 1 次修改<br>​    服务器在 300 秒之内，对数据库进行了 10 次修改<br>​    服务器在 900 秒之内，对数据库进行了 10000 次修改</p>
<h4 id="二，AOF方式："><a href="#二，AOF方式：" class="headerlink" title="二，AOF方式："></a>二，AOF方式：</h4><p>是通过保存Redis服务器所执行的写命令来记录数据库状态的AOF文件刷新方式，有三种：<br>    1.appendfsync always –每提交一个修改命令都调用fsync到AOF文件，非常慢，但是很安全；<br>    2.appendfsync everysec–每秒都调用fsyns刷新到AOF文件，很快但可能丢失一秒内的数据；<br>    3.appendfsync no–依靠OS进行刷新，redis不主动刷新AOF，这样最快但是安全性差；<br>    默认并且推荐每秒刷新，这样在速度和安全上都做到了兼顾<br>    配置如下<br>    appendonly yes #启用AOF<br>    appendfilename appendonly.aof #AOF文件的名称</p>
<pre><code># appendfsync always
appendfsync everysec #每秒钟强制写入磁盘一次
# appendfsync no  
</code></pre><h3 id="II-数据恢复"><a href="#II-数据恢复" class="headerlink" title="II 数据恢复"></a>II 数据恢复</h3><h4 id="1-ROB方式"><a href="#1-ROB方式" class="headerlink" title="1.ROB方式"></a>1.ROB方式</h4><p>​    ROB文件的载入工作是在服务器启动时自动执行的，没有专门用于载入ROB文件命令，只要Redis服务器再启动时检测到ROB文件存在，它就会自动载入ROB的文件，在服务器载入的期间，会一直处于阻塞状态，知道载入工作完成为止</p>
<h4 id="2-AOF方式"><a href="#2-AOF方式" class="headerlink" title="2.AOF方式"></a>2.AOF方式</h4><p>​    服务器在启动时，通过载入和执行AOF文件中保存的命令来还原服务器关闭之前的数据，具体库状态过程：<br>​        载入AOF文件<br>​        创建模拟客户端<br>​        从AOF文件中读取一条命令<br>​        使用模拟客户端执行命令<br>​        循环读取并执行命令，知道全部完成</p>
<p>   注意：如果同时启动了AOF和ROB方式，AOF优先，启动时只加载AOF文件恢复数时之加载</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yzlit.github.io/2019/01/13/数据库四大特性及事务/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="酒夜狸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="酒夜狸个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/13/数据库四大特性及事务/" itemprop="url">数据库ACID特性和事务</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-13T12:23:55+08:00">
                2019-01-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>ACID特性<br>原子性<br>原子性是指数据库事务时不可分割的工作单位。只有使实物中所有的数据库操作都执行成功，才算整个事务成功。事务中任何一个SQL语句执行失败，已经执行成功的SQL语句也必须撤销，退回到事务前的状态。</p>
<p>一致性<br>事务将数据库从一种状态转变为下一种一致的状态。在事务开始之前和事务结束之后，数据库的完整性约束没有被破坏。</p>
<p>隔离性<br>每个读写事务的对象对其他事务的操作对象相互分离，即该事务提交前对其他事务都不可见，通常使用锁来实现。</p>
<p>持久性 </p>
<h2 id="事务一旦提交，其结果就是永久性的。及时发送宕机等故障，数据库也能将数据恢复。"><a href="#事务一旦提交，其结果就是永久性的。及时发送宕机等故障，数据库也能将数据恢复。" class="headerlink" title="事务一旦提交，其结果就是永久性的。及时发送宕机等故障，数据库也能将数据恢复。"></a>事务一旦提交，其结果就是永久性的。及时发送宕机等故障，数据库也能将数据恢复。</h2><p>作者：YinXinLion<br>来源：CSDN<br>原文：<a href="https://blog.csdn.net/qq_27602093/article/details/77069765" target="_blank" rel="noopener">https://blog.csdn.net/qq_27602093/article/details/77069765</a><br>版权声明：本文为博主原创文章，转载请附上博文链接！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yzlit.github.io/2019/01/13/跨域问题/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="酒夜狸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="酒夜狸个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/13/跨域问题/" itemprop="url">跨域问题详解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-13T12:23:55+08:00">
                2019-01-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="一、什么是跨域？"><a href="#一、什么是跨域？" class="headerlink" title="一、什么是跨域？"></a>一、什么是跨域？</h3><p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1547370259736&amp;di=4a7c40b675fb2647cda6e5b6edacbef5&amp;imgtype=0&amp;src=http%3A%2F%2Fp.blog.csdn.net%2Fimages%2Fp_blog_csdn_net%2FPointer_v%2FEntryImages%2F20090212%2Fproxy2.gif" alt="img"></p>
<p>浏览器从一个域名的网页去请求另一个域名的资源时，域名、端口、协议任一不同，都是跨域。跨域访问会访问状态码200但是无法访问，还有其他附带的问题，请求COOKIE无法带上。</p>
<p>比如你从域名为120.258.45 的index.html要访问 156.85.14:8000/getaccess 接口，那么就会有跨域问题。一般尝试跨域访问就会出现No ‘Access-Control-Allow-Origin’ header is present on the requested resource.’ ，类似你可以从谷歌控制台，看到提示：</p>
<p><img src="https://img02.sogoucdn.com/app/a/100520146/3F0EA3D344F60FDDC77F5F96342D521D" alt=""></p>
<h3 id="二、为什么要禁止跨域访问"><a href="#二、为什么要禁止跨域访问" class="headerlink" title="二、为什么要禁止跨域访问"></a>二、为什么要禁止跨域访问</h3><p>这要涉及到浏览器的同源策略，同源策略限制了不同源之间的资源进行交互，用于隔离潜在的恶意文件的安全机制，并且是浏览器最基本的安全机制（同源：协议、域名、端口均相同，localhost和127.0.0.1也属于跨域）。</p>
<p>如果非同源，<strong>同源政策限制三种行为</strong>：</p>
<p>（1） Cookie、LocalStorage 和 IndexDB 无法读取。</p>
<p>（2） DOM 无法获得。</p>
<p>（3） AJAX 请求不能发送。</p>
<p>对于（1） Cookie、LocalStorage 和 IndexDB 无法读取，如果没有同源策略的限制，假设您进入一个受信网站A，输入了账号密码进行登录，服务器端验证通过后会在响应头中添加Set-Cookie字段，在下次访问时，浏览器就会将cookie附加在http请求头字段Cookie中，服务器就知道您已经登录过，下次你再带着这个cookie时访问受信网站A，服务器便不再验证了，如果在cookie信息还存在的情况下，您不小心访问另一个恶意钓鱼网站B，在您不知情的情况下向受信网站A发起了请求，这就相当于不法钓鱼网站登录了您的账户，可以为所欲为了！</p>
<p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1547370029724&amp;di=bb03e9658d9d929fedb977dfea332fa3&amp;imgtype=0&amp;src=http%3A%2F%2Faliyunzixunbucket.oss-cn-beijing.aliyuncs.com%2Fpng%2Fdd2d206d5afa78c483611418500872bc.png" alt="img"></p>
<p>对于（2） DOM 无法获得。又比如一个钓鱼网站，模仿银行网站A（没有了同源策略的限制，钓鱼网站就可以很轻松的网站A的DOM），诱导您输入账户密码信息，你的信息就没了，所以最近12306就是因为类似第三方的访问导致410万用户密码等信息泄漏。</p>
<p>对于（3） AJAX 请求不能发送同源政策规定，AJAX请求只能发给同源的网址，否则就报错。</p>
<p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1547370063925&amp;di=84fd25a37be6345294e3688294f5d791&amp;imgtype=0&amp;src=http%3A%2F%2F5b0988e595225.cdn.sohucs.com%2Fq_70%2Cc_zoom%2Cw_640%2Fimages%2F20180722%2F377baa2adfb34e04b15a80ec41554cdb.jpeg" alt="img"></p>
<h3 id="三、怎么解决跨域问题"><a href="#三、怎么解决跨域问题" class="headerlink" title="三、怎么解决跨域问题"></a>三、怎么解决跨域问题</h3><p>详细的同源策略通过前端解决的介绍可以看阮一峰的文章<br><a href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html</a></p>
<p>除了上述解决方法，服务端解决跨域会用到CORS，CORS是一个W3C标准，全称是”跨域资源共享“。详细的可以见阮一峰的文章<br><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/04/cors.html</a></p>
<h2 id="Nginx配置实例"><a href="#Nginx配置实例" class="headerlink" title="Nginx配置实例"></a>Nginx配置实例</h2><h3 id="实例一：允许example-com的应用在www-example2-com上跨域提取数据"><a href="#实例一：允许example-com的应用在www-example2-com上跨域提取数据" class="headerlink" title="实例一：允许example.com的应用在www.example2.com上跨域提取数据"></a>实例一：允许example.com的应用在<a href="http://www.example2.com上跨域提取数据" target="_blank" rel="noopener">www.example2.com上跨域提取数据</a></h3><p>在nginx.conf里找到server项,并在里面添加如下配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`location /&#123;` `add_header ``&apos;Access-Control-Allow-Origin&apos;` `&apos;http://example.com&apos;``;``add_header ``&apos;Access-Control-Allow-Credentials&apos;` `&apos;true&apos;``;``add_header ``&apos;Access-Control-Allow-Headers&apos;` `&apos;Authorization,Content-Type,Accept,Origin,User-Agent,DNT,Cache-Control,X-Mx-ReqToken,X-Requested-With&apos;``;``add_header ``&apos;Access-Control-Allow-Methods&apos;` `&apos;GET,POST,OPTIONS&apos;``;``...``&#125;`</span><br></pre></td></tr></table></figure>
<p>如果需要允许来自任何域的访问，可以这样配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`add_header Access-Control-Allow-Origin *;`</span><br></pre></td></tr></table></figure>
<p>注释如下</p>
<p>第一条指令：授权从example.com的请求(必需)</p>
<p>第二条指令：当该标志为真时，响应于该请求是否可以被暴露(可选)</p>
<p>第三条指令：允许脚本访问的返回头(可选)</p>
<p>第四条指令：指定请求的方法，可以是GET, POST, OPTIONS, PUT, DELETE等(可选)</p>
<p>重启Nginx</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`$ service nginx reload`</span><br></pre></td></tr></table></figure>
<p>测试跨域请求</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`$ curl -I -X OPTIONS -H ``&quot;Origin: http://example.com&quot;` `http:``//www``.example2.com`</span><br></pre></td></tr></table></figure>
<p>成功时，响应头是如下所示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`HTTP``/1``.1 200 OK``Server: nginx``Access-Control-Allow-Origin: example.com`</span><br></pre></td></tr></table></figure>
<h3 id="实例二：Nginx允许多个域名跨域访问"><a href="#实例二：Nginx允许多个域名跨域访问" class="headerlink" title="实例二：Nginx允许多个域名跨域访问"></a>实例二：Nginx允许多个域名跨域访问</h3><p>由于Access-Control-Allow-Origin参数只允许配置单个域名或者 * ，当我们需要允许多个域名跨域访问时可以用以下几种方法来实现。</p>
<ul>
<li>方法一</li>
</ul>
<p>如需要允许用户请求来自<a href="http://www.example.com、m.example.com、wap.example.com访问www.example2.com域名时，返回头Access-Control-Allow-Origin，具体配置如下" target="_blank" rel="noopener">www.example.com、m.example.com、wap.example.com访问www.example2.com域名时，返回头Access-Control-Allow-Origin，具体配置如下</a></p>
<p>在nginx.conf里面,找到server项,并在里面添加如下配置</p>
<p>具体其他可看：<a href="https://www.cnblogs.com/sunmmi/articles/5956554.html" target="_blank" rel="noopener">https://www.cnblogs.com/sunmmi/articles/5956554.html</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`map $http_origin $corsHost &#123;``    ``default 0;``    ``&quot;~http://www.example.com&quot;` `http:``//www``.example.com;``    ``&quot;~http://m.example.com&quot;` `http:``//m``.example.com;``    ``&quot;~http://wap.example.com&quot;` `http:``//wap``.example.com;``&#125;` `server``&#123;``    ``listen 80;``    ``server_name www.example2.com;``    ``root ``/usr/share/nginx/html``;``    ``location /``    ``&#123;``        ``add_header Access-Control-Allow-Origin $corsHost;``    ``&#125;``&#125;`</span><br></pre></td></tr></table></figure>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="450" src="http://music.163.com/outchain/player?type=0&id=815573174&auto=0&height=430"><br></iframe>

<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="720" height="480" src="https://v.qq.com/txp/iframe/player.html?vid=v0825jzd59q" allowfullscreen="true"></iframe>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yzlit.github.io/2019/01/13/谈谈工作怎么提升自己的计划/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="酒夜狸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="酒夜狸个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/13/谈谈工作怎么提升自己的计划/" itemprop="url">工作之后如何处理好工作和学习的平衡</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-13T12:23:55+08:00">
                2019-01-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h5 id="一，工作"><a href="#一，工作" class="headerlink" title="一，工作"></a>一，工作</h5><p>首先最重要肯定是饭碗，对于大多数人来说，先维持一份薪水还过得去的工作，才能有力气去继续奔跑。</p>
<p>工作当然是枯燥的，CRUD的工作对于很多初级后台开发来说是常事，但是工作仍要做好，做出彩，如果你连工作最基本的都不肯做好，那么你又怎么可能去做好别的事，没有基本的工作，兴趣更是无从谈起。  </p>
<p>要做好工作 ，做出彩，也是要下很大努力的。</p>
<p>第一个就是要注意改进工作方法，提高工作效率。别因为自己的做事方法而耽误自己的时间，那是最蠢的。</p>
<p>工作方法首先是一句话，规划好工作量和工作计划，小步快跑。</p>
<p>规划很重要，不然你不知不觉浪费的时间，就是在慢慢把你拉进水里。</p>
<p>第二句话，懂得职场的规矩，每个公司都有不同的职场氛围，没有一模一样的处事方法，但是为人却是差不多，与人相处，要有诚意，也要保持礼貌，既要尽责地完成自己的工作，在不影响自己的工作和时间情况下，尽量给予帮助。</p>
<p>二，学习</p>
<p>工作了就不学习，过几个月你已经落后你的同学了，再过个一两年，公司把你炒了，你也找不到下家了。</p>
<p>学习，很重要，也要有规划，不能东学一个ES，西学一个微服务，三天打鱼式地刷几道leetcode。</p>
<p>要有规划，首先要计划时间，下班后从几点开始到睡觉前，要干什么，要学什么，进度怎么控制，怎么把学到的东西用起来，记下来。</p>
<p>生活和学习应该放在一起考虑，学习生活才是一种好的状态。</p>
<p>不荒废时光，学一些东西不在于你学了就行，而在于它能最大化提升你的价值，把你的时间花值了。</p>
<p>前路漫漫，坚持，方得始终。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yzlit.github.io/2019/01/12/mysql索引的一些总结/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="酒夜狸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="酒夜狸个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/12/mysql索引的一些总结/" itemprop="url">mysql有关索引的一些总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-12T23:46:47+08:00">
                2019-01-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一、四大索引"><a href="#一、四大索引" class="headerlink" title="一、四大索引"></a>一、四大索引</h2><table>
<thead>
<tr>
<th style="text-align:center">索引类型</th>
<th style="text-align:center">适用范围</th>
<th style="text-align:center">不适用</th>
<th style="text-align:center">效率</th>
<th>引擎</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">全文索引(FULLTEXT)</td>
<td style="text-align:center">char,vachar,text列，用于like %word%</td>
<td style="text-align:center">中文支持不是很好，中文分词插件Mysqlcft，用Apache的Lucene替代</td>
<td style="text-align:center">低</td>
<td>MyISAM</td>
</tr>
<tr>
<td style="text-align:center">HASH</td>
<td style="text-align:center">= in &lt;=&gt;</td>
<td style="text-align:center">范围查询，排序，组合索引，无法避免表扫描</td>
<td style="text-align:center">需要遍历hash表</td>
<td>MEMORY</td>
</tr>
<tr>
<td style="text-align:center">B+树</td>
<td style="text-align:center">普遍适用</td>
<td style="text-align:center"></td>
<td style="text-align:center">与树结构有关</td>
<td>Innodb：1，primary key：主键+其他字段                        2，secondary index：只保存主键指针                   myISAM:叶子结点存放该数据的行指向</td>
</tr>
<tr>
<td style="text-align:center">R树</td>
<td style="text-align:center">geometry数据类型</td>
<td style="text-align:center">范围查找</td>
<td style="text-align:center"></td>
<td>MyISAM、BDb、InnoDb、NDb、Archive</td>
</tr>
</tbody>
</table>
<h2 id="二、有关于B树和B-树的区别"><a href="#二、有关于B树和B-树的区别" class="headerlink" title="二、有关于B树和B+树的区别"></a>二、有关于B树和B+树的区别</h2><ul>
<li>B树中关键字集合分布在整棵树中，叶节点中不包含任何关键字信息，而B+树关键字集合分布在叶子结点中，非叶节点只是叶子结点中关键字的索引；</li>
<li><p>B树中任何一个关键字只出现在一个结点中，而B+树中的关键字必须出现在叶节点中；</p>
</li>
<li><p>不同于B树只适合<strong>随机检索</strong>，B+树同时支持随机检索<strong>和顺序检索</strong>；</p>
</li>
<li>B+树的磁盘读写代价更低。B+树的<strong>内部结点并没有指向关键字具体信息的指针</strong>，其内部结点比B树小，盘块能容纳的结点中关键字数量更多，一次性读入内存中可以查找的关键字也就越多，相对的，IO读写次数也就降低了。而IO读写次数是影响索引检索效率的最大因素。</li>
<li>B+树的查询效率更加稳定。B树搜索有可能会在非叶子结点结束，越靠近根节点的记录查找时间越短，只要找到关键字即可确定记录的存在，其性能等价于在关键字全集内做一次二分查找。而在B+树中，顺序检索比较明显，随机检索时，任何关键字的查找都必须走一条从根节点到叶节点的路，所有关键字的查找路径长度相同，导致每一个关键字的查询效率相当。</li>
<li>数据库索引采用B+树的主要原因是，）B-树在提高了磁盘IO性能的同时并没有解决<strong>元素遍历的效率</strong>低下的问题。B+树的叶子节点使用指针顺序连接在一起，<strong>只要遍历叶子节点就可以实现整棵树的遍历</strong>。而且<strong>在数据库中基于范围的查询是非常频繁的</strong>，而B树不支持这样的操作（或者说效率太低）。</li>
</ul>
<h2 id="三、B-树比B树更适合做文件索引的原因"><a href="#三、B-树比B树更适合做文件索引的原因" class="headerlink" title="三、B+树比B树更适合做文件索引的原因"></a>三、B+树比B树更适合做文件索引的原因</h2><h5 id="（1）B-树空间利用率更高，可减少I-O次数，"><a href="#（1）B-树空间利用率更高，可减少I-O次数，" class="headerlink" title="（1）B+树空间利用率更高，可减少I/O次数，"></a>（1）B+树空间利用率更高，可减少I/O次数，</h5><p>​         一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗。而因为B+树的内部节点只是作为索引使用，而不像B-树那样每个节点都需要存储硬盘指针。<br>​         也就是说：B+树中每个非叶节点没有指向某个关键字具体信息的指针，所以每一个节点可以存放更多的关键字数量，即一次性读入内存所需要查找的关键字也就越多，减少了I/O操作。<br>​     e.g.假设磁盘中的一个盘块容纳16bytes，而一个关键字2bytes，一个关键字具体信息指针2bytes。一棵9阶B-tree(一个结点最多8个关键字)的内   部结点需要2个盘快。而B+ 树内部结点只需要1个盘快。当需要把内部结点读入内存中的时候，B 树就比B+ 树多一次盘块查找时间(在磁盘中就   是         盘片旋转的时间)。</p>
<h5 id="（2）增删文件（节点）时，效率更高，"><a href="#（2）增删文件（节点）时，效率更高，" class="headerlink" title="（2）增删文件（节点）时，效率更高，"></a><strong>（2）增删文件（节点）时，效率更高，</strong></h5><p>​         因为B+树的叶子节点包含所有关键字，并以有序的链表结构存储，这样可很好提高增删效率。</p>
<h5 id="（3）B-树的查询效率更加稳定，"><a href="#（3）B-树的查询效率更加稳定，" class="headerlink" title="（3）B+树的查询效率更加稳定，"></a><strong>（3）B+树的查询效率更加稳定，</strong></h5><p>​    因为B+树的每次查询过程中，都需要遍历从根节点到叶子节点的某条路径。所有关键字的查询路径长度相同，导致每一次查询的效率相当。</p>
<h2 id="四、索引失效的情况"><a href="#四、索引失效的情况" class="headerlink" title="四、索引失效的情况"></a>四、索引失效的情况</h2><p>1，不遵守最左原则</p>
<p>2， like</p>
<p>like ‘%xx’    select * from tb1 where name like ‘%cn’;</p>
<p>3 使用函数<br>select * from tb1 where reverse(name) = ‘wupeiqi’;</p>
<p>4,使用 or 时,or 条件中有未建立索引的列</p>
<p>select <em> from tb1 where nid = 1 or email = <a href="mailto:&#39;seven@live.com" target="_blank" rel="noopener">&#39;seven@live.com</a>‘;<br>特别的：当or条件中有未建立索引的列才失效，以下会走索引<br>        select </em> from tb1 where nid = 1 or name = ‘seven’;<br>        select * from tb1 where nid = 1 or email = <a href="mailto:&#39;seven@live.com" target="_blank" rel="noopener">&#39;seven@live.com</a>‘ and name = ‘alex’- 类型不一致<br>5，使用 ！=   &gt;</p>
<p>如果列是字符串类型，传入条件是必须用引号引起来<br>    特别的：如果是主键，则还是会走索引<br>    select <em> from tb1 where nid != 123   - &gt;    select </em> from tb1 where name &gt; ‘alex’</p>
<p>特别的：如果是主键或索引是整数类型，则还是会走索引<br>select * from tb1 where nid &gt; 123       </p>
<p>select * from tb1 where num &gt; 123- order by    </p>
<p>select email from tb1 order by name desc;</p>
<p>6 ,当根据索引排序时候，选择的映射如果不是索引，则不走索引</p>
<p>特别的：如果对主键排序，则还是走索引：<br>    select * from tb1 order by nid desc</p>
<h2 id="五、sql代码"><a href="#五、sql代码" class="headerlink" title="五、sql代码"></a>五、sql代码</h2><p>查看MySQL慢日志</p>
<p><code>mysqldumpslow -s at -a  /usr/local/`</code>var<code></code>/mysql/MacBook-Pro-3-slow.log`</p>
<p>全文索引</p>
<p>创建ALTER TABLE table ADD INDEX <code>FULLINDEX</code> USING FULLTEXT(<code>cname1</code>[,cname2…]);</p>
<p>使用SELECT * FROM table WHERE MATCH(cname1[,cname2…]) AGAINST (‘word’ MODE );</p>
<p>创建普通索引  </p>
<p>CREATE INDEX index_name ON table_name(col_name);</p>
<p>创建唯一索引</p>
<p>CREATE UNIQUE INDEX index_name ON table_name(col_name);</p>
<p>创建普通组合索引</p>
<p>CREATE INDEX index_name ON table_name(col_name_1,col_name_2);</p>
<p>创建唯一组合索引</p>
<p>CREATE UNIQUE INDEX index_name ON table_name(col_name_1,col_name_2);</p>
<p>通用</p>
<p>ALTER TABLE interface ADD FULLTEXT（INDEX） fullText_index(interfaceName);</p>
<p>直接删除索引</p>
<p>DROP INDEX index_name ON table_name;</p>
<p>–修改表结构删除索引</p>
<p>ALTER TABLE table_name DROP INDEX index_name;</p>
<p>六、 sql优化</p>
<p>1.Innerjoin和左连接，右连接，子查询</p>
<p>A.     inner join内连接也叫等值连接是，left/rightjoin是外连接。能用inner join连接尽量使用inner join连接</p>
<p>B．子查询的性能又比外连接性能慢，尽量用外连接来替换子查询。</p>
<p>C 使用JOIN时候，应该用小的表驱动大表，left join尽量左表小</p>
<p>D 尽量把牵涉到多表联合的查询拆分多个query(多个表查询效率低，容易锁表和阻塞)</p>
<p>详见：<a href="https://blog.csdn.net/heqinghua217/article/details/78600967" target="_blank" rel="noopener">https://blog.csdn.net/heqinghua217/article/details/78600967</a></p>
<p>2.建立索引,加快查询性能.</p>
<p>A，组合索引注意最左原则</p>
<p>B．保证连接表的索引是相同的类型，意思就是A表和B表相关联的字段，必须是同类型的。</p>
<p>C. 索引不会包含有NULL值的列</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yzlit.github.io/2019/01/12/从服务端来讲讲限流的思路/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="酒夜狸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="酒夜狸个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/12/从服务端来讲讲限流的思路/" itemprop="url">从服务端来讲讲限流的思路</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-12T23:46:47+08:00">
                2019-01-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="一-”两窗两桶“限流算法"><a href="#一-”两窗两桶“限流算法" class="headerlink" title="一 ”两窗两桶“限流算法"></a>一 ”两窗两桶“限流算法</h3><h4 id="1、固定窗口"><a href="#1、固定窗口" class="headerlink" title="1、固定窗口"></a>1、固定窗口</h4><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20181222/b991453cf5a74d4ba430f1be5ea6d776.jpg" alt="img"></p>
<p>固定窗口指的是为一定时间段的流量设置一个阈值，超过则触发限流策略（丢弃或者停留），然后直到下一个时间段重新置零开始计数，</p>
<p>这种策略很明显一个缺点是这个时间段的间隔要设置得好，否则会存在一个问题，就是无法“削峰填谷”，当时间间隔设为10秒100个请求量时，本来是应该正常每秒10个请求，但是突然第一秒就来了100个请求，在第一秒就变成100个请求每秒了，所以是没法达到限流缓冲的效果，所以这种策略比较粗暴简单。</p>
<p>「滑动窗口」可以改善上面的问题。</p>
<h4 id="2、滑动窗口"><a href="#2、滑动窗口" class="headerlink" title="2、滑动窗口"></a>2、滑动窗口</h4><p>滑动窗口算法 类似于我们学过TCP的滑动窗口，对固定窗口的一种优化。</p>
<p>滑动窗口就是对固定窗口做了进一步的细分，将原先的粒度切的更细，比如1分钟的固定窗口切分为60个1秒的滑动窗口。然后统计的时间范围随着时间的推移同步后移。</p>
<p><img src="http://5b0988e595225.cdn.sohucs.com/images/20181222/e87df09d3ffd414f88a43c43d0423631.jpg" alt="img"></p>
<p>虽然说滑动窗口可以改善这个问题，但是本质上还是预先划定时间片的方式，属于一种“预测”，意味着几乎肯定无法做到100%的物尽其用。</p>
<p>问题在在于由于访问量的不可预见性，会发生单位时间的前半段大量请求涌入，而后半段则拒绝所有请求的情况。（通常，需要可以将单位时间切的足够的小来缓解 ）其次，我们很难确定这个阈值设置在多少比较合适，只能通过经验或者模拟（如压测）来进行估计，即使是压测也很难估计的准确。集群部署中每台机器的硬件参数不同，可能导致我们需要对每台机器的阈值设置的都不尽相同。同一台机子在不同的时间点的系统压力也不一样（比如晚上还有一些任务，或其他的一些业务操作的影响），能够承受的最大阈值也不尽相同，我们无法考虑的周全。 </p>
<p>所以滑窗模式通常适用于对某一资源的保护的需求上（或者说是承诺比较合适：我对某一接口的提供者承诺过，最高调用量不超过XX），如对db的保护，对某一服务的调用的控制上。  </p>
<h4 id="3，漏桶算法"><a href="#3，漏桶算法" class="headerlink" title="3，漏桶算法"></a>3，漏桶算法</h4><h4 id="4，令牌桶算法"><a href="#4，令牌桶算法" class="headerlink" title="4，令牌桶算法"></a>4，令牌桶算法</h4><h3 id="二、做「限流」的最佳实践"><a href="#二、做「限流」的最佳实践" class="headerlink" title="二、做「限流」的最佳实践"></a><strong>二、做「限流」的最佳实践</strong></h3><h4 id="1、四种策略该如何选择？"><a href="#1、四种策略该如何选择？" class="headerlink" title="1、四种策略该如何选择？"></a>1、四种策略该如何选择？</h4><p>首先，<strong>固定窗口</strong>。一般来说，如非时间紧迫，不建议选择这个方案，太过生硬。但是，为了能快速止损眼前的问题可以作为临时应急的方案。</p>
<p>其次，<strong>滑动窗口</strong>。这个方案适用于对异常结果「高容忍」的场景，毕竟相比“两窗”少了一个缓冲区。但是，胜在实现简单。</p>
<p>然后，<strong>漏桶</strong>。个人觉得这个方案最适合作为一个通用方案。虽说资源的利用率上不是极致，但是「宽进严出」的思路在保护系统的同时还留有一些余地，使得它的适用场景更广。</p>
<p>最后，<strong>令牌桶</strong>。当你需要尽可能的压榨程序的性能（此时桶的最大容量必然会大于等于程序的最大并发能力），并且所处的场景流量进入波动不是很大（不至于一瞬间取完令牌，压垮后端系统）。</p>
<h3 id="三、如何做分布式限流"><a href="#三、如何做分布式限流" class="headerlink" title="三、如何做分布式限流"></a>三、如何做分布式限流</h3><p>如果要分布式限流，那么单机限流的策略其实只需要移植一下，用新的工具如redis+lua 或者nginx+lua 又或者用zookeeper也是可以实现的，下面先具体讲讲redis+lua的分布式限流的思路和代码例子，其他有空再补上。</p>
<p>redis做限流的思路是先设置一个key=service1的记录，值为流量，和时间戳。这些用lua来主要是因为redis不支持事务，而lua脚本是作为一个原子操作一起执行的，lua脚本也是会存在reids内存中作为经常执行的命令串。</p>
<p>下面是固定窗口算法的lua脚本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">local key = KEYS[1]             </span><br><span class="line">local limit = tonumber(KEYS[2])   ## 限流</span><br><span class="line">local current = tonumber(redis.call(&apos;get&apos;, key) or 0)</span><br><span class="line"></span><br><span class="line">if current + 1 &gt; limit then</span><br><span class="line">    return 0</span><br><span class="line">else</span><br><span class="line">    redis.call(&quot;INCRBY&quot;, key,&quot;1&quot;)    ## 对key 加1操作</span><br><span class="line">    redis.call(&quot;EXPIRE&quot;, key,&quot;10&quot;)   ## 过期时间设为10秒</span><br><span class="line">    return 1</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>下面是令牌桶算法的lua脚本</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--- 获取令牌</span></span><br><span class="line"><span class="comment">--- 返回码</span></span><br><span class="line"><span class="comment">--- 0 没有令牌桶配置</span></span><br><span class="line"><span class="comment">--- -1 表示取令牌失败，也就是桶里没有令牌</span></span><br><span class="line"><span class="comment">--- 1 表示取令牌成功</span></span><br><span class="line"><span class="comment">--- @param key 令牌（资源）的唯一标识</span></span><br><span class="line"><span class="comment">--- @param permits 请求令牌数量</span></span><br><span class="line"><span class="comment">--- @param curr_mill_second 当前毫秒数</span></span><br><span class="line"><span class="comment">--- @param context 使用令牌的应用标识</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">acquire</span><span class="params">(key, permits, curr_mill_second, context)</span></span></span><br><span class="line"><span class="comment">---    设置令牌桶的容量为5</span></span><br><span class="line"><span class="comment">--    redis.pcall("HSET", key, "max_permits", "5")  ---桶令牌容量为5</span></span><br><span class="line"><span class="comment">--    redis.pcall("HSET", key, "apps", context)     ---设置要取的key为apps</span></span><br><span class="line"><span class="comment">--    redis.pcall("HSET", key, "rate", "0.2")       ---设置令牌桶每0.2秒增加一个令牌</span></span><br><span class="line"><span class="comment">--    redis.pcall("HSET", key, "curr_permits", "0") ---初始化零时刻时令牌桶的令牌数为0</span></span><br><span class="line"><span class="comment">--    这里可以交由可交由另外的脚本执行。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> rate_limit_info = redis.<span class="built_in">pcall</span>(<span class="string">"HMGET"</span>, key, <span class="string">"last_mill_second"</span>, <span class="string">"curr_permits"</span>, <span class="string">"max_permits"</span>, <span class="string">"rate"</span>, <span class="string">"apps"</span>)</span><br><span class="line"><span class="keyword">local</span> last_mill_second = rate_limit_info[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">local</span> curr_permits = <span class="built_in">tonumber</span>(rate_limit_info[<span class="number">2</span>])</span><br><span class="line"><span class="keyword">local</span> max_permits = <span class="built_in">tonumber</span>(rate_limit_info[<span class="number">3</span>])</span><br><span class="line"><span class="keyword">local</span> rate = rate_limit_info[<span class="number">4</span>]</span><br><span class="line"><span class="keyword">local</span> apps = rate_limit_info[<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">--- 如果没有初始化redis里的令牌桶信息，需要首次初始化令牌桶的一些信息</span></span><br><span class="line"><span class="comment">--if not apps or string.find(apps, context, 1)~=nil then</span></span><br><span class="line"><span class="comment">----- if type(apps) == 'boolean' or apps == nil   then</span></span><br><span class="line"><span class="comment">--redis.pcall("HSET", key, "apps", context)</span></span><br><span class="line"><span class="comment">--apps=context</span></span><br><span class="line"><span class="comment">--end</span></span><br><span class="line"><span class="comment">--if not rate then</span></span><br><span class="line"><span class="comment">--redis.pcall("HSET", key, "rate", "0.2")</span></span><br><span class="line"><span class="comment">--rate=0.2</span></span><br><span class="line"><span class="comment">--end</span></span><br><span class="line"><span class="comment">--if not curr_permits then</span></span><br><span class="line"><span class="comment">--redis.pcall("HSET", key, "curr_permits", "0")</span></span><br><span class="line"><span class="comment">--end</span></span><br><span class="line"><span class="comment">---初始化令牌桶完毕</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> local_curr_permits = max_permits;</span><br><span class="line"><span class="comment">--- 令牌桶刚刚创建，上一次获取令牌的毫秒数为空</span></span><br><span class="line"><span class="comment">--- 根据和上一次向桶里添加令牌的时间和当前时间差，触发式往桶里添加令牌</span></span><br><span class="line"><span class="comment">--- 并且更新上一次向桶里添加令牌的时间</span></span><br><span class="line"><span class="comment">--- 如果向桶里添加的令牌数不足一个，则不更新上一次向桶里添加令牌的时间</span></span><br><span class="line"><span class="comment">--- if (type(last_mill_second) ~= 'boolean' and last_mill_second ~= false and last_mill_second ~= nil) then</span></span><br><span class="line"><span class="comment">--- 桶有初始化 ，其实可以不用判断</span></span><br><span class="line"><span class="keyword">if</span> last_mill_second <span class="keyword">then</span></span><br><span class="line"><span class="keyword">local</span> reverse_permits = <span class="built_in">math</span>.<span class="built_in">floor</span>(((curr_mill_second - last_mill_second) / <span class="number">1000</span>) * rate)</span><br><span class="line"><span class="keyword">local</span> expect_curr_permits = reverse_permits + curr_permits;</span><br><span class="line">local_curr_permits = <span class="built_in">math</span>.<span class="built_in">min</span>(expect_curr_permits, max_permits);  <span class="comment">--- 这是此时此刻的桶令牌的数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--- 大于0表示令牌桶的数量不需要放入，因此时间戳也暂时不更新，等下一次令牌桶有增加时再更新</span></span><br><span class="line"><span class="keyword">if</span> (reverse_permits &gt; <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">redis.<span class="built_in">pcall</span>(<span class="string">"HSET"</span>, key, <span class="string">"last_mill_second"</span>, curr_mill_second)   <span class="comment">--- 更新时间戳</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">redis.<span class="built_in">pcall</span>(<span class="string">"HSET"</span>, key, <span class="string">"last_mill_second"</span>, curr_mill_second)  <span class="comment">--- 这是初始化后的步骤 启用令牌桶，设置时间戳</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">local</span> result = <span class="number">-1</span></span><br><span class="line"><span class="keyword">if</span> (local_curr_permits - permits &gt;= <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">result = <span class="number">1</span></span><br><span class="line">redis.<span class="built_in">pcall</span>(<span class="string">"HSET"</span>, key, <span class="string">"curr_permits"</span>, local_curr_permits - permits)  <span class="comment">--- 更新桶令牌的数量为拿走后剩下的数量</span></span><br><span class="line"><span class="comment">--else</span></span><br><span class="line"><span class="comment">--redis.pcall("HSET", key, "curr_permits", local_curr_permits)            --- 不需要更新桶令牌的数量</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> acquire(KEYS[<span class="number">1</span>],<span class="built_in">tonumber</span>(KEYS[<span class="number">2</span>]),<span class="built_in">tonumber</span>(KEYS[<span class="number">3</span>]),KEYS[<span class="number">4</span>])</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">酒夜狸</p>
              <p class="site-description motion-element" itemprop="description">酒夜狸的个人博客，欢迎探讨有关编程，诗歌，科幻，人生。</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">酒夜狸</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
