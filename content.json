[{"title":"十几年后台工程师来讲讲限流的思路","date":"2019-01-12T15:46:47.000Z","path":"2019/01/12/十几年后台工程师来讲讲限流的思路/","text":"一 ”两窗两桶“限流算法1、固定窗口 固定窗口指的是为一定时间段的流量设置一个阈值，超过则触发限流策略（丢弃或者停留），然后直到下一个时间段重新置零开始计数， 这种策略很明显一个缺点是这个时间段的间隔要设置得好，否则会存在一个问题，就是无法“削峰填谷”，当时间间隔设为10秒100个请求量时，本来是应该正常每秒10个请求，但是突然第一秒就来了100个请求，在第一秒就变成100个请求每秒了，所以是没法达到限流缓冲的效果，所以这种策略比较粗暴简单。 「滑动窗口」可以改善上面的问题。 2、滑动窗口滑动窗口算法 类似于我们学过TCP的滑动窗口，对固定窗口的一种优化。 滑动窗口就是对固定窗口做了进一步的细分，将原先的粒度切的更细，比如1分钟的固定窗口切分为60个1秒的滑动窗口。然后统计的时间范围随着时间的推移同步后移。 虽然说滑动窗口可以改善这个问题，但是本质上还是预先划定时间片的方式，属于一种“预测”，意味着几乎肯定无法做到100%的物尽其用。 问题在在于由于访问量的不可预见性，会发生单位时间的前半段大量请求涌入，而后半段则拒绝所有请求的情况。（通常，需要可以将单位时间切的足够的小来缓解 ）其次，我们很难确定这个阈值设置在多少比较合适，只能通过经验或者模拟（如压测）来进行估计，即使是压测也很难估计的准确。集群部署中每台机器的硬件参数不同，可能导致我们需要对每台机器的阈值设置的都不尽相同。同一台机子在不同的时间点的系统压力也不一样（比如晚上还有一些任务，或其他的一些业务操作的影响），能够承受的最大阈值也不尽相同，我们无法考虑的周全。 所以滑窗模式通常适用于对某一资源的保护的需求上（或者说是承诺比较合适：我对某一接口的提供者承诺过，最高调用量不超过XX），如对db的保护，对某一服务的调用的控制上。 3，漏桶算法4，令牌桶算法二、做「限流」的最佳实践1、四种策略该如何选择？首先，固定窗口。一般来说，如非时间紧迫，不建议选择这个方案，太过生硬。但是，为了能快速止损眼前的问题可以作为临时应急的方案。 其次，滑动窗口。这个方案适用于对异常结果「高容忍」的场景，毕竟相比“两窗”少了一个缓冲区。但是，胜在实现简单。 然后，漏桶。个人觉得这个方案最适合作为一个通用方案。虽说资源的利用率上不是极致，但是「宽进严出」的思路在保护系统的同时还留有一些余地，使得它的适用场景更广。 最后，令牌桶。当你需要尽可能的压榨程序的性能（此时桶的最大容量必然会大于等于程序的最大并发能力），并且所处的场景流量进入波动不是很大（不至于一瞬间取完令牌，压垮后端系统）。 三、如何做分布式限流如果要分布式限流，那么单机限流的策略其实只需要移植一下，用新的工具如redis+lua 或者nginx+lua 又或者用zookeeper也是可以实现的，下面先具体讲讲redis+lua的分布式限流的思路和代码例子，其他有空再补上。 redis做限流的思路是先设置一个key=service1的记录，值为流量，和时间戳。这些用lua来主要是因为redis不支持事务，而lua脚本是作为一个原子操作一起执行的，lua脚本也是会存在reids内存中作为经常执行的命令串。 下面是固定窗口算法的lua脚本 1234567891011local key = KEYS[1] local limit = tonumber(KEYS[2]) ## 限流local current = tonumber(redis.call(&apos;get&apos;, key) or 0)if current + 1 &gt; limit then return 0else redis.call(&quot;INCRBY&quot;, key,&quot;1&quot;) ## 对key 加1操作 redis.call(&quot;EXPIRE&quot;, key,&quot;10&quot;) ## 过期时间设为10秒 return 1end 下面是令牌桶算法的lua脚本 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859--- 获取令牌--- 返回码--- 0 没有令牌桶配置--- -1 表示取令牌失败，也就是桶里没有令牌--- 1 表示取令牌成功--- @param key 令牌（资源）的唯一标识--- @param permits 请求令牌数量--- @param curr_mill_second 当前毫秒数--- @param context 使用令牌的应用标识local function acquire(key, permits, curr_mill_second, context)redis.pcall(&quot;HSET&quot;, key, &quot;max_permits&quot;, &quot;5&quot;)local rate_limit_info = redis.pcall(&quot;HMGET&quot;, key, &quot;last_mill_second&quot;, &quot;curr_permits&quot;, &quot;max_permits&quot;, &quot;rate&quot;, &quot;apps&quot;)local last_mill_second = rate_limit_info[1]local curr_permits = tonumber(rate_limit_info[2])local max_permits = tonumber(rate_limit_info[3])local rate = rate_limit_info[4]local apps = rate_limit_info[5]--- 标识没有配置令牌桶if type(apps) == &apos;boolean&apos; or apps == nil or string.find(apps, context, 1)~=nil thenredis.pcall(&quot;HSET&quot;, key, &quot;apps&quot;, context)apps=contextendif type(rate) == &apos;boolean&apos; or rate == nil thenredis.pcall(&quot;HSET&quot;, key, &quot;rate&quot;, &quot;0.2&quot;)rate=0.2endif type(curr_permits) == &apos;boolean&apos; or curr_permits == nil thenredis.pcall(&quot;HSET&quot;, key, &quot;curr_permits&quot;, &quot;0&quot;)endlocal local_curr_permits = max_permits;--- 令牌桶刚刚创建，上一次获取令牌的毫秒数为空--- 根据和上一次向桶里添加令牌的时间和当前时间差，触发式往桶里添加令牌--- 并且更新上一次向桶里添加令牌的时间--- 如果向桶里添加的令牌数不足一个，则不更新上一次向桶里添加令牌的时间if (type(last_mill_second) ~= &apos;boolean&apos; and last_mill_second ~= false and last_mill_second ~= nil) thenlocal reverse_permits = math.floor(((curr_mill_second - last_mill_second) / 1000) * rate)local expect_curr_permits = reverse_permits + curr_permits;local_curr_permits = math.min(expect_curr_permits, max_permits);--- 大于0表示不是第一次获取令牌，也没有向桶里添加令牌if (reverse_permits &gt; 0) thenredis.pcall(&quot;HSET&quot;, key, &quot;last_mill_second&quot;, curr_mill_second)endelseredis.pcall(&quot;HSET&quot;, key, &quot;last_mill_second&quot;, curr_mill_second)endlocal result = -1if (local_curr_permits - permits &gt;= 0) thenresult = 1redis.pcall(&quot;HSET&quot;, key, &quot;curr_permits&quot;, local_curr_permits - permits)elseredis.pcall(&quot;HSET&quot;, key, &quot;curr_permits&quot;, local_curr_permits)endreturn resultendreturn acquire(KEYS[1],tonumber(KEYS[2]),tonumber(KEYS[3]),KEYS[4])","tags":[{"name":"限流,固定窗口,滑动窗口,漏桶,令牌桶","slug":"限流-固定窗口-滑动窗口-漏桶-令牌桶","permalink":"https://yzlit.github.io/tags/限流-固定窗口-滑动窗口-漏桶-令牌桶/"}]}]