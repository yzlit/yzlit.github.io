[{"title":"跨域问题详解","date":"2019-01-13T04:23:55.000Z","path":"2019/01/13/Cross-domain-Access/","text":"一、什么是跨域？ 浏览器从一个域名的网页去请求另一个域名的资源时，域名、端口、协议任一不同，都是跨域。跨域访问会访问状态码200但是无法访问，还有其他附带的问题，请求COOKIE无法带上。 比如你从域名为120.258.45 的index.html要访问 156.85.14:8000/getaccess 接口，那么就会有跨域问题。一般尝试跨域访问就会出现No ‘Access-Control-Allow-Origin’ header is present on the requested resource.’ ，类似你可以从谷歌控制台，看到提示： 二、为什么要禁止跨域访问这要涉及到浏览器的同源策略，同源策略限制了不同源之间的资源进行交互，用于隔离潜在的恶意文件的安全机制，并且是浏览器最基本的安全机制（同源：协议、域名、端口均相同，localhost和127.0.0.1也属于跨域）。 如果非同源，同源政策限制三种行为： （1） Cookie、LocalStorage 和 IndexDB 无法读取。 （2） DOM 无法获得。 （3） AJAX 请求不能发送。 对于（1） Cookie、LocalStorage 和 IndexDB 无法读取，如果没有同源策略的限制，假设您进入一个受信网站A，输入了账号密码进行登录，服务器端验证通过后会在响应头中添加Set-Cookie字段，在下次访问时，浏览器就会将cookie附加在http请求头字段Cookie中，服务器就知道您已经登录过，下次你再带着这个cookie时访问受信网站A，服务器便不再验证了，如果在cookie信息还存在的情况下，您不小心访问另一个恶意钓鱼网站B，在您不知情的情况下向受信网站A发起了请求，这就相当于不法钓鱼网站登录了您的账户，可以为所欲为了！ 对于（2） DOM 无法获得。又比如一个钓鱼网站，模仿银行网站A（没有了同源策略的限制，钓鱼网站就可以很轻松的网站A的DOM），诱导您输入账户密码信息，你的信息就没了，所以最近12306就是因为类似第三方的访问导致410万用户密码等信息泄漏。 对于（3） AJAX 请求不能发送同源政策规定，AJAX请求只能发给同源的网址，否则就报错。 三、怎么解决跨域问题详细的同源策略通过前端解决的介绍可以看阮一峰的文章http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html 除了上述解决方法，服务端解决跨域会用到CORS，CORS是一个W3C标准，全称是”跨域资源共享“。详细的可以见阮一峰的文章http://www.ruanyifeng.com/blog/2016/04/cors.html Nginx配置实例实例一：允许example.com的应用在www.example2.com上跨域提取数据在nginx.conf里找到server项,并在里面添加如下配置 1`location /&#123;` `add_header ``&apos;Access-Control-Allow-Origin&apos;` `&apos;http://example.com&apos;``;``add_header ``&apos;Access-Control-Allow-Credentials&apos;` `&apos;true&apos;``;``add_header ``&apos;Access-Control-Allow-Headers&apos;` `&apos;Authorization,Content-Type,Accept,Origin,User-Agent,DNT,Cache-Control,X-Mx-ReqToken,X-Requested-With&apos;``;``add_header ``&apos;Access-Control-Allow-Methods&apos;` `&apos;GET,POST,OPTIONS&apos;``;``...``&#125;` 如果需要允许来自任何域的访问，可以这样配置 1`add_header Access-Control-Allow-Origin *;` 注释如下 第一条指令：授权从example.com的请求(必需) 第二条指令：当该标志为真时，响应于该请求是否可以被暴露(可选) 第三条指令：允许脚本访问的返回头(可选) 第四条指令：指定请求的方法，可以是GET, POST, OPTIONS, PUT, DELETE等(可选) 重启Nginx 1`$ service nginx reload` 测试跨域请求 1`$ curl -I -X OPTIONS -H ``&quot;Origin: http://example.com&quot;` `http:``//www``.example2.com` 成功时，响应头是如下所示 1`HTTP``/1``.1 200 OK``Server: nginx``Access-Control-Allow-Origin: example.com` 实例二：Nginx允许多个域名跨域访问由于Access-Control-Allow-Origin参数只允许配置单个域名或者 * ，当我们需要允许多个域名跨域访问时可以用以下几种方法来实现。 方法一 如需要允许用户请求来自www.example.com、m.example.com、wap.example.com访问www.example2.com域名时，返回头Access-Control-Allow-Origin，具体配置如下 在nginx.conf里面,找到server项,并在里面添加如下配置 具体其他可看：https://www.cnblogs.com/sunmmi/articles/5956554.html 1`map $http_origin $corsHost &#123;`` ``default 0;`` ``&quot;~http://www.example.com&quot;` `http:``//www``.example.com;`` ``&quot;~http://m.example.com&quot;` `http:``//m``.example.com;`` ``&quot;~http://wap.example.com&quot;` `http:``//wap``.example.com;``&#125;` `server``&#123;`` ``listen 80;`` ``server_name www.example2.com;`` ``root ``/usr/share/nginx/html``;`` ``location /`` ``&#123;`` ``add_header Access-Control-Allow-Origin $corsHost;`` ``&#125;``&#125;`","tags":[{"name":"跨域访问","slug":"跨域访问","permalink":"https://yzlit.github.io/tags/跨域访问/"}]},{"title":"从服务端来讲讲限流的思路","date":"2019-01-12T15:46:47.000Z","path":"2019/01/12/十几年后台工程师来讲讲限流的思路/","text":"一 ”两窗两桶“限流算法1、固定窗口 固定窗口指的是为一定时间段的流量设置一个阈值，超过则触发限流策略（丢弃或者停留），然后直到下一个时间段重新置零开始计数， 这种策略很明显一个缺点是这个时间段的间隔要设置得好，否则会存在一个问题，就是无法“削峰填谷”，当时间间隔设为10秒100个请求量时，本来是应该正常每秒10个请求，但是突然第一秒就来了100个请求，在第一秒就变成100个请求每秒了，所以是没法达到限流缓冲的效果，所以这种策略比较粗暴简单。 「滑动窗口」可以改善上面的问题。 2、滑动窗口滑动窗口算法 类似于我们学过TCP的滑动窗口，对固定窗口的一种优化。 滑动窗口就是对固定窗口做了进一步的细分，将原先的粒度切的更细，比如1分钟的固定窗口切分为60个1秒的滑动窗口。然后统计的时间范围随着时间的推移同步后移。 虽然说滑动窗口可以改善这个问题，但是本质上还是预先划定时间片的方式，属于一种“预测”，意味着几乎肯定无法做到100%的物尽其用。 问题在在于由于访问量的不可预见性，会发生单位时间的前半段大量请求涌入，而后半段则拒绝所有请求的情况。（通常，需要可以将单位时间切的足够的小来缓解 ）其次，我们很难确定这个阈值设置在多少比较合适，只能通过经验或者模拟（如压测）来进行估计，即使是压测也很难估计的准确。集群部署中每台机器的硬件参数不同，可能导致我们需要对每台机器的阈值设置的都不尽相同。同一台机子在不同的时间点的系统压力也不一样（比如晚上还有一些任务，或其他的一些业务操作的影响），能够承受的最大阈值也不尽相同，我们无法考虑的周全。 所以滑窗模式通常适用于对某一资源的保护的需求上（或者说是承诺比较合适：我对某一接口的提供者承诺过，最高调用量不超过XX），如对db的保护，对某一服务的调用的控制上。 3，漏桶算法4，令牌桶算法二、做「限流」的最佳实践1、四种策略该如何选择？首先，固定窗口。一般来说，如非时间紧迫，不建议选择这个方案，太过生硬。但是，为了能快速止损眼前的问题可以作为临时应急的方案。 其次，滑动窗口。这个方案适用于对异常结果「高容忍」的场景，毕竟相比“两窗”少了一个缓冲区。但是，胜在实现简单。 然后，漏桶。个人觉得这个方案最适合作为一个通用方案。虽说资源的利用率上不是极致，但是「宽进严出」的思路在保护系统的同时还留有一些余地，使得它的适用场景更广。 最后，令牌桶。当你需要尽可能的压榨程序的性能（此时桶的最大容量必然会大于等于程序的最大并发能力），并且所处的场景流量进入波动不是很大（不至于一瞬间取完令牌，压垮后端系统）。 三、如何做分布式限流如果要分布式限流，那么单机限流的策略其实只需要移植一下，用新的工具如redis+lua 或者nginx+lua 又或者用zookeeper也是可以实现的，下面先具体讲讲redis+lua的分布式限流的思路和代码例子，其他有空再补上。 redis做限流的思路是先设置一个key=service1的记录，值为流量，和时间戳。这些用lua来主要是因为redis不支持事务，而lua脚本是作为一个原子操作一起执行的，lua脚本也是会存在reids内存中作为经常执行的命令串。 下面是固定窗口算法的lua脚本 1234567891011local key = KEYS[1] local limit = tonumber(KEYS[2]) ## 限流local current = tonumber(redis.call(&apos;get&apos;, key) or 0)if current + 1 &gt; limit then return 0else redis.call(&quot;INCRBY&quot;, key,&quot;1&quot;) ## 对key 加1操作 redis.call(&quot;EXPIRE&quot;, key,&quot;10&quot;) ## 过期时间设为10秒 return 1end 下面是令牌桶算法的lua脚本 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859--- 获取令牌--- 返回码--- 0 没有令牌桶配置--- -1 表示取令牌失败，也就是桶里没有令牌--- 1 表示取令牌成功--- @param key 令牌（资源）的唯一标识--- @param permits 请求令牌数量--- @param curr_mill_second 当前毫秒数--- @param context 使用令牌的应用标识local function acquire(key, permits, curr_mill_second, context)redis.pcall(&quot;HSET&quot;, key, &quot;max_permits&quot;, &quot;5&quot;)local rate_limit_info = redis.pcall(&quot;HMGET&quot;, key, &quot;last_mill_second&quot;, &quot;curr_permits&quot;, &quot;max_permits&quot;, &quot;rate&quot;, &quot;apps&quot;)local last_mill_second = rate_limit_info[1]local curr_permits = tonumber(rate_limit_info[2])local max_permits = tonumber(rate_limit_info[3])local rate = rate_limit_info[4]local apps = rate_limit_info[5]--- 标识没有配置令牌桶if type(apps) == &apos;boolean&apos; or apps == nil or string.find(apps, context, 1)~=nil thenredis.pcall(&quot;HSET&quot;, key, &quot;apps&quot;, context)apps=contextendif type(rate) == &apos;boolean&apos; or rate == nil thenredis.pcall(&quot;HSET&quot;, key, &quot;rate&quot;, &quot;0.2&quot;)rate=0.2endif type(curr_permits) == &apos;boolean&apos; or curr_permits == nil thenredis.pcall(&quot;HSET&quot;, key, &quot;curr_permits&quot;, &quot;0&quot;)endlocal local_curr_permits = max_permits;--- 令牌桶刚刚创建，上一次获取令牌的毫秒数为空--- 根据和上一次向桶里添加令牌的时间和当前时间差，触发式往桶里添加令牌--- 并且更新上一次向桶里添加令牌的时间--- 如果向桶里添加的令牌数不足一个，则不更新上一次向桶里添加令牌的时间if (type(last_mill_second) ~= &apos;boolean&apos; and last_mill_second ~= false and last_mill_second ~= nil) thenlocal reverse_permits = math.floor(((curr_mill_second - last_mill_second) / 1000) * rate)local expect_curr_permits = reverse_permits + curr_permits;local_curr_permits = math.min(expect_curr_permits, max_permits);--- 大于0表示不是第一次获取令牌，也没有向桶里添加令牌if (reverse_permits &gt; 0) thenredis.pcall(&quot;HSET&quot;, key, &quot;last_mill_second&quot;, curr_mill_second)endelseredis.pcall(&quot;HSET&quot;, key, &quot;last_mill_second&quot;, curr_mill_second)endlocal result = -1if (local_curr_permits - permits &gt;= 0) thenresult = 1redis.pcall(&quot;HSET&quot;, key, &quot;curr_permits&quot;, local_curr_permits - permits)elseredis.pcall(&quot;HSET&quot;, key, &quot;curr_permits&quot;, local_curr_permits)endreturn resultendreturn acquire(KEYS[1],tonumber(KEYS[2]),tonumber(KEYS[3]),KEYS[4])","tags":[{"name":"限流,固定窗口,滑动窗口,漏桶,令牌桶","slug":"限流-固定窗口-滑动窗口-漏桶-令牌桶","permalink":"https://yzlit.github.io/tags/限流-固定窗口-滑动窗口-漏桶-令牌桶/"}]}]